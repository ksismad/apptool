<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>App ID Analyzer (ksismad)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <style>
    html, body { background: #f3f4f6; color: #1e293b; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0; }
    .container { max-width: 1200px; margin: 36px auto; background: #fff; border-radius: 18px; box-shadow: 0 8px 32px rgba(60,60,100,0.11); overflow: hidden; }
    .header { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: #fff; padding: 32px; position: relative; }
    .header h1 { margin: 0 0 8px; font-size: 2.25rem; }
    .user-info { position: absolute; top: 16px; right: 32px; background: rgba(255,255,255,0.15); padding: 7px 16px; border-radius: 20px; font-size: 0.93rem; }

    .upload-section { display: flex; gap: 24px; padding: 32px; flex-wrap: wrap; }
    .upload-box { flex: 1; min-width: 300px; background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 24px; position: relative; transition: border-color .2s, background .2s; }
    .upload-box.source2 { border-color: #059669; background: #f0fdf4; }
    .upload-box.source2::after { content: "(Paid Source)"; color: #059669; font-size: .875rem; display: block; margin-top:8px; }
    .upload-box.dragover { border-color: #6366f1; background: #eef4ff; }
    .file-input { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
    .upload-btn { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: #fff; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    .upload-btn.source2 { background: linear-gradient(135deg, #059669, #10b981); }
    .file-info { margin-top: 12px; padding:8px 16px; background: #d1fae5; color: #059669; border-radius:6px; display:none; }
    .file-info.show { display:inline-block; }
    .file-list {margin-top:8px;font-size:.98em;padding-left:0;list-style-type:none;}
    .file-list li{margin-bottom:2px;}
    .merge-btn {margin-top:8px;background:#38bdf8;color:#fff;border:none;padding:6px 16px;border-radius:6px;cursor:pointer;font-weight:600;}
    .column-mappings, .options-section, .results { padding: 0 32px; }
    .mapping-group, .option-group { margin-bottom: 24px; }
    select, input[type="number"] { padding:8px 12px; border:1px solid #cbd5e1; border-radius:6px; }
    .analyze-btn { width: calc(100% - 64px); margin:32px; padding:16px; background: linear-gradient(135deg, #10b981, #059669); color:#fff; border:none; border-radius:12px; font-size:1.2rem; font-weight:600; cursor:pointer;}
    .analyze-btn:disabled { background:#9ca3af; cursor:not-allowed; }
    .gst-section {margin-bottom:12px;}
    .gst-section label {margin-right:10px;}
    .alert-container { display: flex; flex-wrap: wrap; gap: 24px; margin-bottom: 32px; }
    .alert-box { background: #fff7ed; border-left: 5px solid #f59e42; border-radius: 10px; box-shadow: 0 2px 10px rgba(60,60,100,0.06); padding: 18px 18px 10px 20px; flex: 1 1 330px; min-width:320px; max-width:420px; margin-bottom:12px;}
    .alert-title { font-size:1.12rem; font-weight:700; margin-bottom:2px; color: #d97706;}
    .alert-count { font-size:1.2rem; font-weight:800; color: #b45309; margin-bottom:6px;}
    .alert-table { width:100%; border-collapse:collapse; font-size:0.99em;}
    .alert-table th, .alert-table td { border-bottom:1px solid #f3e8ff; padding:6px 6px;}
    .alert-table th { background:#f3f4f6;}
    .alert-table tr:last-child td { border-bottom: none;}
    .alert-table .amount-cell{ text-align:right;font-family:monospace;}
    .alert-table .paid-cell { color: #059669; font-weight:bold;}
    .alert-table .unpaid-cell { color:#dc2626; font-weight:bold;}
    .alert-table .comm-cell { text-align:right; font-family:monospace;}
    .alert-table small {color:#7c7c7c;}
    .loading-overlay { position:fixed; inset:0; background:rgba(255,255,255,0.9); display:flex; align-items:center; justify-content:center; z-index:1000; visibility:hidden; opacity:0; transition:opacity .2s;}
    .loading-overlay.show { visibility:visible; opacity:1; }
    .spinner { width:40px; height:40px; border:4px solid #f3f3f3; border-top:4px solid #3498db; border-radius:50%; animation:spin 1s linear infinite; }
    .error-message { margin:16px 32px; padding:12px 16px; background:#fee2e2; color:#b91c1c; border-radius:8px; display:none; }
    .error-message.show { display:block; }
    @keyframes spin { 0%{transform:rotate(0);}100%{transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="user-info" id="user-info">User: ksismad | UTC <span id="utc-dt"></span></div>
      <h1>üîç App ID Analyzer</h1>
      <p>Advanced red alert scenario display ‚Äì robust S1 status detection, file-to-file merge, multi-format support, GST control</p>
    </div>
    <div class="upload-section">
      <div class="upload-box" id="drop1">
        <h3>Source 1 Files</h3>
        <input type="file" id="file-input-1" class="file-input" multiple accept=".xlsx,.xls,.csv">
        <button class="upload-btn" id="upload-btn-1">Choose Files</button>
        <div id="file-info-1" class="file-info"></div>
        <ul id="file-list-1" class="file-list"></ul>
        <button id="merge-btn-1" class="merge-btn" style="display:none;">Merge File to File (S1)</button>
      </div>
      <div class="upload-box source2" id="drop2">
        <h3>Source 2 Files (Paid)</h3>
        <input type="file" id="file-input-2" class="file-input" multiple accept=".xlsx,.xls,.csv">
        <button class="upload-btn source2" id="upload-btn-2">Choose Files</button>
        <div id="file-info-2" class="file-info"></div>
        <ul id="file-list-2" class="file-list"></ul>
      </div>
    </div>
    <div id="column-mappings" class="column-mappings"></div>
    <div class="options-section">
      <div class="gst-section">
        <label><input type="checkbox" id="apply-gst"> Apply 18% GST to S1</label>
        <label><input type="checkbox" id="gst-round"> Round GST Amount</label>
      </div>
      <div class="option-group">
        <label>Analysis Type:</label>
        <select id="analysis-type">
          <option value="all">All Records</option>
          <option value="redalerts">Red Alerts Only</option>
        </select>
        <label><input type="checkbox" id="include-commission"> Include Commission Analysis</label>
      </div>
    </div>
    <div id="error-message" class="error-message"></div>
    <button id="analyze-btn" class="analyze-btn" disabled>Analyze Data</button>
    <div id="results" class="results"></div>
  </div>
  <div id="loading-overlay" class="loading-overlay"><div class="spinner"></div></div>
  <script>
    // Hardcode Experience Yet Modern Smartass Coder Mode ON

    // STATE
    const STATE = {
      source1Files: [],
      source2Files: [],
      columnMappings: {},
      analysisOptions: { type: 'all', includeCommission: false, applyGST: false, gstRound: false }
    };
    // DOM
    const DOM = {
      fileInput1: document.getElementById('file-input-1'),
      fileInput2: document.getElementById('file-input-2'),
      uploadBtn1: document.getElementById('upload-btn-1'),
      uploadBtn2: document.getElementById('upload-btn-2'),
      drop1: document.getElementById('drop1'),
      drop2: document.getElementById('drop2'),
      fileInfo1: document.getElementById('file-info-1'),
      fileInfo2: document.getElementById('file-info-2'),
      fileList1: document.getElementById('file-list-1'),
      fileList2: document.getElementById('file-list-2'),
      mergeBtn1: document.getElementById('merge-btn-1'),
      columnMappings: document.getElementById('column-mappings'),
      analysisType: document.getElementById('analysis-type'),
      includeCommission: document.getElementById('include-commission'),
      applyGST: document.getElementById('apply-gst'),
      gstRound: document.getElementById('gst-round'),
      analyzeBtn: document.getElementById('analyze-btn'),
      results: document.getElementById('results'),
      loadingOverlay: document.getElementById('loading-overlay'),
      errorMessage: document.getElementById('error-message'),
      userInfo: document.getElementById('user-info'),
      utcDt: document.getElementById('utc-dt')
    };

    function showLoading() { DOM.loadingOverlay.classList.add('show'); }
    function hideLoading() { DOM.loadingOverlay.classList.remove('show'); }
    function showError(msg) {
      DOM.errorMessage.textContent = msg;
      DOM.errorMessage.classList.add('show');
      setTimeout(() => DOM.errorMessage.classList.remove('show'), 5000);
    }
    function updateUserInfo() {
      const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
      DOM.utcDt.textContent = now;
    }

    // FILE HANDLERS AND UI (multi upload, file-to-file merge)
    function initFileHandlers() {
      DOM.uploadBtn1.onclick = e => { e.preventDefault(); DOM.fileInput1.value = ''; DOM.fileInput1.click(); };
      DOM.fileInput1.onchange = e => { if (e.target.files.length) handleMultiFileSelection(e.target.files, 1); };
      DOM.uploadBtn2.onclick = e => { e.preventDefault(); DOM.fileInput2.value = ''; DOM.fileInput2.click(); };
      DOM.fileInput2.onchange = e => { if (e.target.files.length) handleMultiFileSelection(e.target.files, 2); };
      DOM.mergeBtn1.onclick = () => { showS1FileMergeDialog(); };
      [ {drop:DOM.drop1,src:1}, {drop:DOM.drop2,src:2} ].forEach(o => {
        o.drop.ondragover = e => { e.preventDefault(); o.drop.classList.add('dragover'); };
        o.drop.ondragleave = e => { e.preventDefault(); o.drop.classList.remove('dragover'); };
        o.drop.ondrop = e => {
          e.preventDefault();
          o.drop.classList.remove('dragover');
          const files = e.dataTransfer.files;
          if (files.length) handleMultiFileSelection(files, o.src);
        };
      });
    }

    // Accepts .xlsx, .xls, .csv, auto-detects
    function processAnyFile(file, cb) {
      const ext = file.name.split('.').pop().toLowerCase();
      if (["xlsx", "xls"].includes(ext)) {
        processExcelFile(file, cb);
      } else if (ext === "csv") {
        processCSVFile(file, cb);
      } else {
        cb(new Error("Unsupported file type"));
      }
    }
    function processExcelFile(file, cb) {
      const rd = new FileReader();
      rd.onload = e => {
        try {
          const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
          const js = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { header: 1 });
          if (js.length < 2) return cb(new Error('No data rows'));
          cb(null, js);
        } catch (er) { cb(er); }
      };
      rd.onerror = () => cb(new Error('Read error'));
      rd.readAsArrayBuffer(file);
    }
    function processCSVFile(file, cb) {
      const rd = new FileReader();
      rd.onload = e => {
        try {
          const wb = XLSX.read(e.target.result, { type: 'string' });
          const js = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { header: 1 });
          if (js.length < 2) return cb(new Error('No data rows'));
          cb(null, js);
        } catch (er) { cb(er); }
      };
      rd.onerror = () => cb(new Error('Read error'));
      rd.readAsText(file);
    }

    function handleMultiFileSelection(files, src) {
      showLoading();
      let fileArr = Array.from(files);
      if (src === 1) {
        STATE.source1Files = [];
        DOM.fileList1.innerHTML = '';
        let loaded = 0;
        fileArr.forEach((f, idx) => {
          processAnyFile(f, (err, data) => {
            if (!err) {
              STATE.source1Files.push({ file: f, headers: data[0], records: data.slice(1) });
              let li = document.createElement('li');
              li.textContent = f.name + ` (${data.length-1} rows)`;
              DOM.fileList1.appendChild(li);
            } else {
              showError(`S1: ${f.name} - ${err.message}`);
            }
            loaded++;
            if (loaded === fileArr.length) {
              DOM.fileInfo1.textContent = fileArr.map(x => x.name).join(', ');
              DOM.fileInfo1.classList.add('show');
              DOM.mergeBtn1.style.display = fileArr.length > 1 ? 'inline-block' : 'none';
              hideLoading();
              setupColumnMappings();
              updateAnalyzeBtn();
            }
          });
        });
      } else {
        STATE.source2Files = [];
        DOM.fileList2.innerHTML = '';
        let loaded = 0;
        fileArr.forEach((f, idx) => {
          processAnyFile(f, (err, data) => {
            if (!err) {
              STATE.source2Files.push({ file: f, headers: data[0], records: data.slice(1).map(row => { let obj = {...row}; obj.isPaid = true; return obj; }) });
              let li = document.createElement('li');
              li.textContent = f.name + ` (${data.length-1} rows)`;
              DOM.fileList2.appendChild(li);
            } else {
              showError(`S2: ${f.name} - ${err.message}`);
            }
            loaded++;
            if (loaded === fileArr.length) {
              DOM.fileInfo2.textContent = fileArr.map(x => x.name).join(', ');
              DOM.fileInfo2.classList.add('show');
              hideLoading();
              setupColumnMappings();
              updateAnalyzeBtn();
            }
          });
        });
      }
    }

    // S1 file-to-file merge dialog
    function showS1FileMergeDialog() {
      if (STATE.source1Files.length < 2) return;
      let names = STATE.source1Files.map((f,i)=>`${i+1}. ${f.file.name}`);
      let srcIdx = prompt("S1 file merge: Enter the source file number to merge FROM:\n" + names.join("\n"));
      let tgtIdx = prompt("S1 file merge: Enter the target file number to merge INTO:\n" + names.join("\n"));
      if (!srcIdx || !tgtIdx) return;
      srcIdx = parseInt(srcIdx.trim(),10)-1;
      tgtIdx = parseInt(tgtIdx.trim(),10)-1;
      if (srcIdx === tgtIdx || srcIdx < 0 || tgtIdx < 0 || srcIdx >= STATE.source1Files.length || tgtIdx >= STATE.source1Files.length) {
        showError("Invalid merge selection.");
        return;
      }
      let srcFile = STATE.source1Files[srcIdx];
      let tgtFile = STATE.source1Files[tgtIdx];
      if (JSON.stringify(srcFile.headers) !== JSON.stringify(tgtFile.headers)) {
        showError("Can't merge: Headers do not match between files.");
        return;
      }
      tgtFile.records = tgtFile.records.concat(srcFile.records);
      STATE.source1Files.splice(srcIdx,1);
      DOM.fileList1.innerHTML = '';
      STATE.source1Files.forEach((f) => {
        let li = document.createElement('li');
        li.textContent = f.file.name + ` (${f.records.length} rows)`;
        DOM.fileList1.appendChild(li);
      });
      DOM.fileInfo1.textContent = STATE.source1Files.map(x => x.file.name).join(', ');
      DOM.fileInfo1.classList.add('show');
      if (STATE.source1Files.length > 1) DOM.mergeBtn1.style.display = 'inline-block';
      else DOM.mergeBtn1.style.display = 'none';
      setupColumnMappings();
      updateAnalyzeBtn();
    }

    // COLUMN MAP: auto-detect per file (S1), disables S2 commission and status
    function setupColumnMappings() {
      const s1 = STATE.source1Files[0];
      const s2 = STATE.source2Files[0];
      const h1 = s1 ? s1.headers : [];
      const h2 = s2 ? s2.headers : [];
      if (!h1.length || !h2.length) return;
      // S1: appId, amount, commission, date, status
      // S2: appId, amount, date
      const cols = [
        { id: 'appId', lbl: 'App ID', patt: [/app.?id/i, /id/i] },
        { id: 'amount', lbl: 'Amount', patt: [/amount/i, /total/i] },
        { id: 'commission', lbl: 'Commission', patt: [/commiss|tds|fee|charge/i] },
        { id: 'date', lbl: 'Date', patt: [/date/i, /timestamp/i, /txn.*date/i, /created/i] },
        { id: 'status', lbl: 'Status', patt: [/status/i, /state/i, /paid|unpaid|not paid|fail/i] }
      ];
      let html = `<div class="mapping-group"><strong>Column Mappings</strong>`;
      cols.forEach(c => {
        html += `<div><label>${c.lbl}:</label>
                  <select id="ms1-${c.id}"><option value="">Select S1</option>${
                    h1.map((h, i) => `<option value="${i}">${h}</option>`).join('')
                  }</select>`;
        if (c.id !== 'commission') {
          html += `<select id="ms2-${c.id}"><option value="">Select S2</option>${
                    h2.map((h, i) => `<option value="${i}">${h}</option>`).join('')
                  }</select>`;
        }
        html += `</div>`;
      });
      html += `</div>`;
      DOM.columnMappings.innerHTML = html;
      cols.forEach(c => {
        const s1sel = document.getElementById(`ms1-${c.id}`);
        const s2sel = document.getElementById(`ms2-${c.id}`);
        const auto1 = findMatch(h1, c.patt), auto2 = findMatch(h2, c.patt);
        if (auto1 !== '') s1sel.value = auto1;
        if (s2sel && auto2 !== '') s2sel.value = auto2;
        [s1sel, s2sel].forEach(el => { if (el) el.onchange = updateColumnMappings; });
      });
      updateColumnMappings();
    }
    function findMatch(h, p) {
      for (let r of p) {
        const idx = h.findIndex(x => x && r.test(x));
        if (idx !== -1) return idx;
      }
      return '';
    }
    function updateColumnMappings() {
      STATE.columnMappings = {};
      ['appId', 'amount', 'commission', 'date', 'status'].forEach(k => {
        let s1el = document.getElementById(`ms1-${k}`);
        let s2el = document.getElementById(`ms2-${k}`);
        STATE.columnMappings[k] = {
          source1: s1el ? s1el.value : "",
          source2: s2el ? s2el.value : ""
        };
      });
      updateAnalyzeBtn();
    }

    function updateAnalyzeBtn() {
      const ok = STATE.source1Files.length > 0 && STATE.source2Files.length > 0 &&
        Object.values(STATE.columnMappings).every(m => m.source1 && (m.source2 !== undefined));
      DOM.analyzeBtn.disabled = !ok;
      DOM.analyzeBtn.textContent = ok ? 'Analyze Data' : 'Please select & map columns';
    }

    // GST logic
    function applyGSTAmount(amount) {
      let amt = parseFloat(amount) || 0;
      if (DOM.applyGST.checked) {
        amt = amt * 1.18;
        if (DOM.gstRound.checked) amt = Math.round(amt);
        else amt = Number(amt.toFixed(2));
      }
      return amt;
    }

    // Robust paid/unpaid detection for S1:
    // Paid if commission is not blank/zero AND status data cell does NOT contain negative words (and not 'unpaid')
    // Unpaid if commission is blank/zero OR status data cell contains negative words or 'unpaid'
    function getS1Status(r, headers, commissionIdx, statusIdx) {
      let comm = commissionIdx !== undefined && commissionIdx !== "" && commissionIdx !== null ? r[headers[commissionIdx]] : undefined;
      if (comm === undefined || comm === null || comm === "" || (typeof comm === "string" && comm.trim() === "") || Number(comm) === 0) return "Unpaid";
      if (statusIdx !== undefined && statusIdx !== "" && statusIdx !== null) {
        let statusText = r[headers[statusIdx]];
        if (typeof statusText === "string") {
          let s = statusText.trim().toLowerCase();
          if (/unpaid|fail|cancel|not[\s_-]*paid|pending|await|reject|bounce|decline|invalid|hold|error|reversed|dispute|withheld|void/.test(s)) return "Unpaid";
          if (/paid|success|completed|done|approved/.test(s)) return "Paid";
        }
      }
      return "Paid";
    }
    function getS2Status() { return "Paid"; }

    // ANALYSIS
    function analyzeData() {
      const s1 = STATE.source1Files[0];
      const s2 = STATE.source2Files[0];
      if (!s1 || !s2) { showError("Please select and map at least one file from each source."); return {}; }
      const d1 = s1.records;
      const d2 = s2.records;
      const m = STATE.columnMappings;
      const commIdx1 = m.commission.source1;
      const statusIdx1 = m.status ? m.status.source1 : null;
      // Index S2 by AppId
      const map2 = new Map();
      d2.forEach(r => {
        const id = r[s2.headers[m.appId.source2]];
        if (id) map2.set(id.toString(), r);
      });
      // Duplicate maps
      const s1DupMap = {}, s2DupMap = {};
      d1.forEach(r => { let id = r[s1.headers[m.appId.source1]]; if (!id) return; s1DupMap[id] = (s1DupMap[id]||0)+1; });
      d2.forEach(r => { let id = r[s2.headers[m.appId.source2]]; if (!id) return; s2DupMap[id] = (s2DupMap[id]||0)+1; });
      // Buckets
      const scenarios = {
        "S1 Paid but missing in S2": [],
        "S2 Paid but missing in S1": [],
        "S2 Paid, S1 Unpaid": [],
        "S2 Paid, S1 Paid but amount different": [],
        "S2 Paid, S1 Unpaid and amount different": [],
        "Commission deviation (for S1 Paid)": [],
        "Duplicates in S1": [],
        "Duplicates in S2": [],
        "S1 Paid, S2 Paid but amount different": []
      };
      // S1 driven
      d1.forEach(r1 => {
        const id = r1[s1.headers[m.appId.source1]];
        if (!id) return;
        const r2 = map2.get(id.toString());
        const s1status = getS1Status(r1, s1.headers, m.commission.source1, m.status ? m.status.source1 : null);
        const s2status = r2 ? getS2Status() : null;
        let a1 = applyGSTAmount(r1[s1.headers[m.amount.source1]]);
        let a2 = r2 ? applyGSTAmount(r2[s2.headers[m.amount.source2]]) : 0;
        let comm1 = m.commission.source1 !== "" && m.commission.source1 !== undefined ? r1[s1.headers[m.commission.source1]] : undefined;
        // S1 Paid but missing in S2
        if (s1status === "Paid" && !r2)
          scenarios["S1 Paid but missing in S2"].push({ appId: id, s1Amount: a1, s1Status: s1status, date: r1[s1.headers[m.date.source1]] });
        // S2 Paid, S1 Unpaid
        if (r2 && s2status === "Paid" && s1status === "Unpaid")
          scenarios["S2 Paid, S1 Unpaid"].push({ appId: id, s1Amount: a1, s2Amount: a2, s1Status, s2Status: s2status, date: r1[s1.headers[m.date.source1]] });
        // S2 Paid, S1 Paid but amount different
        if (r2 && s2status === "Paid" && s1status === "Paid" && Math.abs(a1 - a2) > 0.01)
          scenarios["S2 Paid, S1 Paid but amount different"].push({ appId: id, s1Amount: a1, s2Amount: a2, s1Status, s2Status: s2status, date: r1[s1.headers[m.date.source1]] });
        // S2 Paid, S1 Unpaid and amount different
        if (r2 && s2status === "Paid" && s1status === "Unpaid" && Math.abs(a1 - a2) > 0.01)
          scenarios["S2 Paid, S1 Unpaid and amount different"].push({ appId: id, s1Amount: a1, s2Amount: a2, s1Status, s2Status: s2status, date: r1[s1.headers[m.date.source1]] });
        // S1 Paid, S2 Paid but amount different
        if (r2 && s1status === "Paid" && s2status === "Paid" && Math.abs(a1 - a2) > 0.01)
          scenarios["S1 Paid, S2 Paid but amount different"].push({ appId: id, s1Amount: a1, s2Amount: a2, s1Status, s2Status: s2status, date: r1[s1.headers[m.date.source1]] });
        // Commission deviation (for S1 Paid)
        if (STATE.analysisOptions.includeCommission && s1status === "Paid") {
          let expected = a1 * 0.02;
          let commVal = parseFloat(comm1) || 0;
          if (Math.abs(commVal - expected) > 0.01)
            scenarios["Commission deviation (for S1 Paid)"].push({ appId: id, s1Amount: a1, commission: commVal, expectedCommission: expected.toFixed(2), date: r1[s1.headers[m.date.source1]] });
        }
        // Duplicates in S1
        if (s1DupMap[id] && s1DupMap[id] > 1) {
          scenarios["Duplicates in S1"].push({ appId: id, s1Amount: a1, s1Status: s1status, date: r1[s1.headers[m.date.source1]] });
        }
      });
      // S2 driven
      d2.forEach(r2 => {
        const id = r2[s2.headers[m.appId.source2]];
        if (!id) return;
        const s2status = getS2Status();
        const r1 = d1.find(x => x[s1.headers[m.appId.source1]] == id);
        let a2 = applyGSTAmount(r2[s2.headers[m.amount.source2]]);
        // S2 Paid but missing in S1
        if (!r1 && s2status === "Paid")
          scenarios["S2 Paid but missing in S1"].push({ appId: id, s2Amount: a2, s2Status: s2status, date: r2[s2.headers[m.date.source2]] });
        // Duplicates in S2
        if (s2DupMap[id] && s2DupMap[id] > 1) {
          scenarios["Duplicates in S2"].push({ appId: id, s2Amount: a2, s2Status: s2status, date: r2[s2.headers[m.date.source2]] });
        }
      });
      return scenarios;
    }

    function displayResults(scenarios) {
      const titles = {
        "S1 Paid but missing in S2": "S1 Paid but missing in S2",
        "S2 Paid but missing in S1": "S2 Paid but missing in S1",
        "S2 Paid, S1 Unpaid": "S2 Paid, S1 Unpaid",
        "S2 Paid, S1 Paid but amount different": "S2 Paid, S1 Paid but amount different",
        "S2 Paid, S1 Unpaid and amount different": "S2 Paid, S1 Unpaid and amount different",
        "Commission deviation (for S1 Paid)": "Commission deviation (for S1 Paid)",
        "Duplicates in S1": "Duplicates in S1",
        "Duplicates in S2": "Duplicates in S2",
        "S1 Paid, S2 Paid but amount different": "S1 Paid, S2 Paid but amount different"
      };
      let html = '<div class="alert-container">';
      Object.entries(scenarios).forEach(([key, arr]) => {
        if (!arr.length) return;
        html += `<div class="alert-box"><div class="alert-title">${titles[key]}</div>
        <div class="alert-count">${arr.length}</div>
        <div style="overflow-x:auto">
        <table class="alert-table"><thead><tr>`;
        let fields = Object.keys(arr[0]);
        html += fields.map(f => `<th>${f.replace(/([A-Z])/g, ' $1')}</th>`).join('');
        html += '</tr></thead><tbody>';
        arr.slice(0, 8).forEach(item => {
          html += '<tr>';
          fields.forEach(f => {
            let v = item[f];
            let cls = '';
            if (f.toLowerCase().includes('status')) cls = v === "Paid" ? "paid-cell" : "unpaid-cell";
            if (f.toLowerCase().includes('amount')) cls = "amount-cell";
            if (f.toLowerCase().includes('comm')) cls = "comm-cell";
            html += `<td class="${cls}">${v === undefined ? "-" : v}</td>`;
          });
          html += '</tr>';
        });
        html += '</tbody></table>';
        if (arr.length > 8) html += `<small>Showing first 8 of ${arr.length} records</small>`;
        html += `</div></div>`;
      });
      html += '</div>';
      DOM.results.innerHTML = html;
      DOM.results.classList.add('show');
    }

    DOM.analyzeBtn.onclick = () => {
      showLoading();
      setTimeout(() => {
        try {
          const scenarios = analyzeData();
          displayResults(scenarios);
        } catch (e) { showError(e.message || e); }
        hideLoading();
      }, 100);
    };

    document.addEventListener('DOMContentLoaded', () => {
      initFileHandlers();
      updateUserInfo();
      setInterval(updateUserInfo, 15000);
      DOM.analysisType.onchange = DOM.includeCommission.onchange = DOM.applyGST.onchange = DOM.gstRound.onchange = function () {
        STATE.analysisOptions.type = DOM.analysisType.value;
        STATE.analysisOptions.includeCommission = DOM.includeCommission.checked;
        STATE.analysisOptions.applyGST = DOM.applyGST.checked;
        STATE.analysisOptions.gstRound = DOM.gstRound.checked;
      };
    });
  </script>
</body>
</html>
