<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Reconciliation & Analysis Suite (ksismad)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #4C51BF; --primary-dark: #434190;
            --secondary-color: #38A169; --secondary-dark: #2F855A;
            --light-gray: #f7fafc; --medium-gray: #e2e8f0;
            --dark-gray: #2d3748; --text-color: #4a5568;
            --white: #fff; --danger-color: #c53030; --warning-color: #dd6b20;
            --highlight-color: #fff3cd; --red-alert-bg: #fed7d7;
        }
        html, body { 
            background: #f3f4f6; color: var(--text-color); 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0; padding: 0; line-height: 1.6;
        }
        .container { 
            max-width: 1500px; margin: 30px auto; background: var(--white); 
            border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.1); overflow: hidden;
        }
        .header { 
            background: linear-gradient(135deg, #5A67D8 0%, #7F5AD5 100%); 
            color: var(--white); padding: 30px 40px; position: relative;
        }
        .header h1 { margin: 0; font-size: 2.5rem; font-weight: 700; }
        .user-info {
            position: absolute; top: 20px; right: 30px; background: rgba(255,255,255,0.2);
            padding: 8px 16px; border-radius: 99px; font-size: 0.9rem; font-weight: 500;
        }
        .main-content { padding: 30px 40px; }
        .upload-section { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        .upload-box {
            background: var(--light-gray); border: 2px dashed var(--medium-gray);
            border-radius: 12px; padding: 25px; transition: all 0.2s ease;
        }
        .upload-box:hover { border-color: #c3dafe; background: #f1f5f9; }
        .upload-box h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.25rem; color: var(--dark-gray); }
        .file-input { display: none; }
        .upload-btn {
            background: var(--primary-color); color: var(--white); border: none; 
            padding: 10px 20px; border-radius: 8px; cursor: pointer; 
            font-weight: 600; transition: background 0.2s ease;
        }
        .upload-btn:hover { background: var(--primary-dark); }
        .file-info {
            margin-top: 15px; padding: 10px; background: #e6fffa; color: #2c7a7b; 
            border-radius: 6px; font-weight: 500; display: none; word-break: break-all;
        }
        .file-info.show { display: block; }
        .options-section, .column-mapping, .commission-section {
            background: var(--light-gray); border-radius: 12px;
            padding: 25px; margin-bottom: 30px;
        }
        .options-section h3, .column-mapping h3, .commission-section h3 { margin-top: 0; margin-bottom: 20px; color: var(--dark-gray); }
        .options-grid, .mapping-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
        }
        .mapping-box h4 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--dark-gray); }
        .mapping-row { display: flex; align-items: center; margin-bottom: 12px; }
        .mapping-label { flex: 1; font-weight: 600; padding-right: 10px;}
        .mapping-select, .commission-input {
            padding: 8px; border: 1px solid #cbd5e1;
            border-radius: 6px; background: var(--white);
        }
        .commission-input { width: 80px; }
        .analyze-btn {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--secondary-dark) 100%);
            color: var(--white); border: none; border-radius: 12px; font-size: 1.25rem; 
            font-weight: 700; cursor: pointer; transition: all 0.2s ease;
        }
        .analyze-btn:hover { box-shadow: 0 4px 15px rgba(47, 133, 90, 0.4); }
        .analyze-btn:disabled { background: #a0aec0; cursor: not-allowed; box-shadow: none; }
        .results, #duplicates-section, #executive-summary { margin-top: 30px; display: none; }
        .results.show, #duplicates-section.show, #executive-summary.show { display: block; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(600px, 1fr)); gap: 30px; }
        .result-box {
            background: var(--white); border: 1px solid var(--medium-gray);
            border-radius: 12px; display: flex; flex-direction: column;
        }
        .result-box.red-alert { border-color: var(--danger-color); }
        .result-header {
            padding: 15px 20px; background: var(--light-gray);
            border-bottom: 1px solid var(--medium-gray); display: flex;
            justify-content: space-between; align-items: center;
        }
        .result-header.red-alert { background-color: var(--red-alert-bg); }
        .result-header h3 { margin: 0; color: var(--dark-gray); }
        .view-full-btn {
            background: none; border: 1px solid #cbd5e1; color: var(--text-color);
            padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 0.9rem;
        }
        .view-full-btn:hover { background: #edf2f7; }
        .table-container { overflow: auto; height: 400px; flex-grow: 1; }
        .results-table { width: 100%; border-collapse: collapse; }
        .results-table th, .results-table td {
            padding: 12px 15px; text-align: left; border-bottom: 1px solid var(--medium-gray);
            white-space: nowrap;
        }
        .results-table tr.duplicate-row td { background-color: var(--highlight-color); }
        .results-table th { background: var(--light-gray); font-weight: 600; position: sticky; top: 0; z-index: 1;}
        .results-table th.sortable { cursor: pointer; }
        .results-table th.sortable:hover { background: #edf2f7; }
        .result-footer {
            padding: 10px 20px; background: var(--light-gray); font-weight: 600;
            border-top: 1px solid var(--medium-gray); text-align: right;
        }
        .commission-table { width: 100%; border-collapse: collapse; }
        .commission-table th { text-align: left; padding: 8px; font-size: 0.9em; }
        .commission-table td { padding: 8px; border-bottom: 1px solid var(--medium-gray); vertical-align: middle; }
        #executive-summary {
            background: linear-gradient(135deg, #eff6ff, #e0e7ff); border: 2px solid var(--primary-color);
            padding: 25px; border-radius: 12px;
        }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .summary-card { text-align: center; }
        .summary-card h4 { margin: 0 0 10px 0; color: var(--primary-dark); }
        .summary-value { font-size: 2rem; font-weight: 700; color: var(--danger-color); }
        .loading-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.85); display: flex; align-items: center;
            justify-content: center; z-index: 9999; display: none;
        }
        .loading-overlay.show { display: flex; }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="user-info" id="user-info"></div>
            <h1>Professional Reconciliation & Analysis Suite</h1>
            <p>The definitive tool for intelligent financial data comparison and analysis.</p>
        </div>
        
        <div class="main-content">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>Source 1 (Master Data)</h3>
                    <input type="file" id="file-input-1" class="file-input" multiple accept=".xlsx,.xls,.csv">
                    <button class="upload-btn" onclick="document.getElementById('file-input-1').click()">Choose Master File(s)</button>
                    <div id="file-info-1" class="file-info"></div>
                </div>
                <div class="upload-box">
                    <h3>Source 2 (Comparison Data)</h3>
                    <input type="file" id="file-input-2" class="file-input" accept=".xlsx,.xls,.csv">
                    <button class="upload-btn" onclick="document.getElementById('file-input-2').click()">Choose Comparison File</button>
                    <div id="file-info-2" class="file-info"></div>
                </div>
            </div>

            <div id="column-mapping-section" class="column-mapping" style="display: none;">
                <h3>Column Mapping</h3>
                <p>Please verify the automatically detected columns. Fields marked with * are required for analysis.</p>
                <div class="mapping-grid">
                    <div id="source1-mappings"></div>
                    <div id="source2-mappings"></div>
                </div>
            </div>
            
            <div id="commission-control-section" class="commission-section" style="display: none;">
                <h3>Financial Control Center</h3>
                <p>Manage file-specific commission, TDS, and additional amounts before analysis.</p>
                <div id="commission-controls"></div>
            </div>

            <div class="options-section">
                <h3>Global Filters & Options</h3>
                <div class="options-grid">
                    <div>
                        <label for="date1-from" class="mapping-label">Source 1 Date Range</label>
                        <input type="date" id="date1-from"> to <input type="date" id="date1-to">
                    </div>
                    <div>
                        <label for="date2-from" class="mapping-label">Source 2 Date Range</label>
                        <input type="date" id="date2-from"> to <input type="date" id="date2-to">
                    </div>
                    <div>
                        <label for="status-filter" class="mapping-label">Filter Source 1 by Status</label>
                        <select id="status-filter" class="mapping-select">
                            <option value="all">All Records</option>
                            <option value="paid">Paid</option>
                            <option value="unpaid">Unpaid</option>
                        </select>
                    </div>
                     <div>
                        <label for="apply-gst" class="mapping-label">Apply 18% GST to Source 1</label>
                        <input type="checkbox" id="apply-gst">
                    </div>
                    <div>
                        <label for="round-off" class="mapping-label">Round Off Source 1 Amount</label>
                        <input type="checkbox" id="round-off">
                    </div>
                    <div>
                         <label for="expected-commission" class="mapping-label">Expected Commission %</label>
                         <input type="number" id="expected-commission" class="commission-input" value="0">
                    </div>
                </div>
            </div>
            
            <button id="analyze-btn" class="analyze-btn" disabled>Upload & Map Files to Begin</button>
            
            <div id="executive-summary"></div>
            <div id="duplicates-section" class="commission-section">
                <h3>Duplicate ID Report</h3>
                <div id="duplicates-display"></div>
            </div>

            <div id="results" class="results">
                <h2>Analysis Results</h2>
                <div class="results-grid">
                    <div id="red-alert-box" class="result-box red-alert"></div>
                    <div id="commission-deviation-box" class="result-box"></div>
                    <div id="matches-box" class="result-box"></div>
                    <div id="mismatches-box" class="result-box"></div>
                    <div id="missing2-box" class="result-box"></div>
                    <div id="missing1-box" class="result-box"></div>
                </div>
                 <button id="export-btn" class="upload-btn" style="margin-top: 20px; display: none;">Export Spectacular Report</button>
            </div>
        </div>
    </div>
    
    <div id="loading-overlay" class="loading-overlay"><div class="spinner"></div></div>
    
    <script>
        const STATE = {
            source1: { files: new Map(), data: [], headers: [], mappings: {}, financialControls: {} },
            source2: { files: new Map(), data: [], headers: [], mappings: {} },
            analysisResults: null,
            duplicates: { source1: new Set(), source2: new Set() }
        };

        const COLUMN_CONFIG = {
            appId: { label: 'Application ID', patterns: [/app.*id/i, /application.*id/i, /id/i], required: true },
            amount: { label: 'Amount (Taxable Value)', patterns: [/amount/i, /total/i, /value/i, /fee/i], required: true },
            date: { label: 'Date', patterns: [/date/i, /timestamp/i, /created/i], required: false },
            status: { label: 'Status', patterns: [/status/i, /state/i], required: false },
            commission: { label: 'Commission', patterns: [/commission/i, /comm/i], required: false }
        };
        const DOM = {
            analyzeBtn: document.getElementById('analyze-btn'),
            userInfo: document.getElementById('user-info'),
            columnMappingSection: document.getElementById('column-mapping-section'),
            commissionControlSection: document.getElementById('commission-control-section'),
            duplicatesSection: document.getElementById('duplicates-section'),
            duplicatesDisplay: document.getElementById('duplicates-display'),
            executiveSummary: document.getElementById('executive-summary'),
            resultsSection: document.getElementById('results'),
            exportBtn: document.getElementById('export-btn'),
            loadingOverlay: document.getElementById('loading-overlay')
        };
        
        async function processFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array', cellDates: true });
                        const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { header: 1, defval: "" });
                        resolve(jsonData);
                    } catch (err) { reject(new Error(`Could not process file ${file.name}: ${err.message}`)); }
                };
                reader.onerror = () => reject(new Error(`Could not read file ${file.name}`));
                reader.readAsArrayBuffer(file);
            });
        }

        function generateFileSignature(data) {
            const headers = data[0] || [];
            const appIdIndex = headers.findIndex(h => COLUMN_CONFIG.appId.patterns.some(p => p.test(h)));
            if (appIdIndex === -1) return headers.join(',');
            return data.slice(1, 6).map(row => row[appIdIndex]).join(',');
        }

        async function handleFileSelection(files, sourceNum) {
            if (!files.length) return;
            showLoading();
            
            const sourceKey = `source${sourceNum}`;
            const stateObj = STATE[sourceKey];

            try {
                let headers = stateObj.headers.length ? stateObj.headers : (await processFile(files[0]))[0];
                stateObj.headers = headers;

                if (sourceNum === 2) { 
                    stateObj.files.clear();
                    stateObj.data = [];
                }

                for (const file of files) {
                    const fileData = await processFile(file);
                    if (fileData.length < 2) continue;
                    const signature = generateFileSignature(fileData);
                    if (stateObj.files.has(signature)) {
                        alert(`Skipping duplicate file: ${file.name}`);
                        continue;
                    }
                    stateObj.files.set(signature, file.name);
                    const records = fileData.slice(1).map(row => ({ __filename: file.name, data: row }));
                    stateObj.data.push(...records);
                }
                
                stateObj.mappings = detectColumnMappings(stateObj.headers);
                updateFileInfo(sourceNum);
                createColumnMappingUI(sourceNum);

                if (sourceNum === 1 && stateObj.files.size > 0) {
                    initializeFinancialControls();
                    renderFinancialControls();
                    DOM.commissionControlSection.style.display = 'block';
                }

            } catch (err) {
                alert(`Error: ${err.message}`);
            } finally {
                if (STATE.source1.files.size > 0 && STATE.source2.files.size > 0) {
                    DOM.columnMappingSection.style.display = 'block';
                }
                hideLoading();
                updateAnalyzeButton();
            }
        }
        
        function runAnalysis() {
            showLoading();
            setTimeout(() => {
                try {
                    checkForDuplicates();

                    const { appId: s1AppIdCol, amount: s1AmountCol, commission: s1CommissionCol, status: s1StatusCol } = STATE.source1.mappings;
                    const { appId: s2AppIdCol, amount: s2AmountCol } = STATE.source2.mappings;
                    const applyGst = document.getElementById('apply-gst').checked;
                    const roundOff = document.getElementById('round-off').checked;
                    const expectedCommissionRate = parseFloat(document.getElementById('expected-commission').value) / 100 || 0;
                    
                    const processedS1Data = STATE.source1.data.map(s1item => {
                        const s1row = s1item.data;
                        const controls = STATE.source1.financialControls[s1item.__filename];
                        if (!controls) return s1item; // Should not happen, but a safeguard.

                        const originalFilename = s1item.__filename;
                        const targetFilename = controls.mergedInto || originalFilename;

                        let amount = parseFloat(s1row[s1AmountCol]) || 0;
                        if (applyGst) amount *= 1.18;
                        amount += controls.additionalAmount;
                        if (roundOff) amount = Math.round(amount);

                        let commission = (s1CommissionCol !== undefined && !controls.mergedInto) ? (parseFloat(s1row[s1CommissionCol]) || 0) : 0;
                        if (controls.mergedInto) {
                            // If this file's commission is merged, its individual commission becomes zero.
                            commission = 0;
                        }

                        let tds = commission * (controls.tdsPercent / 100);

                        // Create a new object for the processed data
                        return {
                            ...s1item,
                            processed: {
                                amount,
                                commission,
                                tds,
                                originalFilename,
                                targetFilename
                            }
                        };
                    });
                    
                    // Add merged commissions to target files
                    for (const fileName in STATE.source1.financialControls) {
                        const controls = STATE.source1.financialControls[fileName];
                        if (controls.mergedInto) {
                            processedS1Data.forEach(item => {
                                if (item.processed.targetFilename === controls.mergedInto) {
                                    const commissionToMerge = (STATE.source1.financialControls[fileName].originalCommission || 0);
                                    item.processed.commission += commissionToMerge;
                                    item.processed.tds = item.processed.commission * (STATE.source1.financialControls[controls.mergedInto].tdsPercent / 100);
                                }
                            });
                        }
                    }

                    const s1Map = new Map();
                    processedS1Data.forEach(item => {
                        const appId = item.data[s1AppIdCol];
                        if (appId) s1Map.set(appId.toString(), item);
                    });

                    const s2Filtered = getFilteredData(2);
                    const results = { matches: [], mismatches: [], redAlerts: [], commissionDeviations: [] };
                    const s1ItemsFound = new Set();

                    s2Filtered.forEach(s2item => {
                        const s2row = s2item.data;
                        const s2AppId = s2row[s2AppIdCol]?.toString();
                        const s1item = s1Map.get(s2AppId);
                        
                        let s2Amount = parseFloat(s2row[s2AmountCol]) || 0;

                        if (s1item) {
                            s1ItemsFound.add(s2AppId);
                            const { amount: s1Amount, commission, tds, targetFilename } = s1item.processed;
                            
                            const status = Math.abs(s1Amount - s2Amount) < 0.01 ? 'Match' : 'Mismatch';
                            results[status.toLowerCase() + 'es'].push({ appId: s2AppId, amount1: s1Amount, amount2: s2Amount, commission, tds, status, filename1: targetFilename, date1: parseDate(s1item.data[s1item.mappings.date]), date2: parseDate(s2row[s2item.mappings.date]) });
                            
                            const s1Status = s1item.data[s1StatusCol]?.toString().toLowerCase();
                            if (s1Status === 'unpaid') {
                                results.redAlerts.push({appId: s2AppId, amount: s2Amount, reason: `Paid in S2, but 'Unpaid' in S1`});
                            }
                        } else {
                            results.redAlerts.push({appId: s2AppId, amount: s2Amount, reason: `Paid in S2, but MISSING in S1`});
                        }
                    });

                    results.missingInSource2 = processedS1Data
                        .filter(item => !s1ItemsFound.has(item.data[s1AppIdCol]?.toString()))
                        .map(item => {
                            const { amount, commission, tds, targetFilename } = item.processed;
                            return { appId: item.data[s1AppIdCol], amount1: amount, commission, tds, filename1: targetFilename, date1: parseDate(item.data[item.mappings.date]) };
                        });

                    if (expectedCommissionRate > 0 && s1CommissionCol !== undefined) {
                        processedS1Data.forEach(s1item => {
                            const taxableValue = parseFloat(s1item.data[s1AmountCol]) || 0;
                            const actualCommission = parseFloat(s1item.data[s1CommissionCol]) || 0;
                            if (taxableValue > 0) {
                                const actualRate = actualCommission / taxableValue;
                                if (Math.abs(actualRate - expectedCommissionRate) > 0.0001) {
                                    results.commissionDeviations.push({
                                        appId: s1item.data[s1AppIdCol], taxableValue, actualCommission,
                                        actualRate: actualRate * 100, expectedRate: expectedCommissionRate * 100,
                                        deviation: actualCommission - (taxableValue * expectedCommissionRate)
                                    });
                                }
                            }
                        });
                    }

                    STATE.analysisResults = results;
                    displayExecutiveSummary(results);
                    displayResults(results);
                } catch (error) {
                    console.error("Analysis Error:", error);
                    alert('An error occurred during analysis: ' + error.message);
                } finally {
                    hideLoading();
                }
            }, 50);
        }
        
        function displayExecutiveSummary(results) {
            DOM.executiveSummary.classList.add('show');
            const totalRedAlertAmount = results.redAlerts.reduce((sum, item) => sum + item.amount, 0);
            const totalCommissionDeviation = results.commissionDeviations.reduce((sum, item) => sum + item.deviation, 0);
            const totalPotentialLoss = totalRedAlertAmount - totalCommissionDeviation; // Subtracting because negative deviation is a loss

            const topMismatches = [...results.mismatches]
                .sort((a,b) => Math.abs((b.amount1 - b.amount2)/b.amount2) - Math.abs((a.amount1 - a.amount2)/a.amount1))
                .slice(0,3)
                .map(item => `<li>${item.appId} (${(((item.amount1 - item.amount2)/item.amount2)*100).toFixed(2)}%)</li>`).join('');

            DOM.executiveSummary.innerHTML = `
                <h3>Executive Summary</h3>
                <div class="summary-grid">
                    <div class="summary-card">
                        <h4>Total Potential Loss</h4>
                        <div class="summary-value">${totalPotentialLoss.toFixed(2)}</div>
                        <small>(Red Alerts + Commission Deviations)</small>
                    </div>
                    <div class="summary-card">
                        <h4>Red Alert Items</h4>
                        <div class="summary-value" style="color: var(--danger-color);">${results.redAlerts.length}</div>
                        <small>Totaling ${totalRedAlertAmount.toFixed(2)}</small>
                    </div>
                     <div class="summary-card">
                        <h4>Commission Deviations</h4>
                        <div class="summary-value" style="color: var(--warning-color);">${results.commissionDeviations.length}</div>
                        <small>Totaling ${totalCommissionDeviation.toFixed(2)}</small>
                    </div>
                    <div class="summary-card">
                         <h4>Top 3 Mismatches by Variance</h4>
                         <ul style="text-align: left; padding-left: 20px;">${topMismatches || '<li>N/A</li>'}</ul>
                    </div>
                </div>
            `;
        }

        function displayResults(results) {
            buildResultTable('red-alert', 'Red Alert Discrepancies', ['App ID', 'S2 Amount', 'Reason'], results.redAlerts);
            buildResultTable('commission-deviation', 'Commission Deviation Report', ['App ID', 'Taxable Value', 'Actual Commission', 'Actual Rate %', 'Expected Rate %', 'Deviation'], results.commissionDeviations);
            buildResultTable('matches', 'Matches', ['App ID', 'Amount', 'Date', 'Filename'], results.matches);
            buildResultTable('mismatches', 'Mismatches', ['App ID', 'S1 Amount', 'S2 Amount', 'Diff', 'Variance %', 'Commission', 'TDS', 'S1 Date', 'S2 Date', 'Filename'], results.mismatches);
            buildResultTable('missing2', 'Missing in Source 2', ['App ID', 'Amount', 'Commission', 'TDS', 'Date', 'Filename'], results.missingInSource2);
            document.getElementById('missing1-box').innerHTML = ''; // This box is now obsolete

            DOM.resultsSection.classList.add('show');
            DOM.exportBtn.style.display = 'inline-block';
        }

        function buildResultTable(id, title, headers, data) {
            const container = document.getElementById(`${id}-box`);
            if (!data || data.length === 0) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'flex';

            let totalAmount1 = 0, totalAmount2 = 0;
            
            let tableHTML = `<div class="result-header ${id.includes('red') ? 'red-alert' : ''}"><h3>${title}</h3><button class="view-full-btn">View Full</button></div>
                             <div class="table-container"><table class="results-table"><thead><tr>`;
            headers.forEach(h => tableHTML += `<th class="sortable" data-sort-key="${h.toLowerCase().replace(/ /g, '').replace('%', '')}">${h}</th>`);
            tableHTML += `</tr></thead><tbody>`;

            const dups = new Set(id.includes('1') ? [...STATE.duplicates.source2] : [...STATE.duplicates.source1]);
            data.forEach(item => {
                totalAmount1 += item.amount1 || 0;
                totalAmount2 += item.amount2 || 0;
                const isDuplicate = dups.has(item.appId);
                const variance = item.amount1 && item.amount2 ? ((item.amount1 - item.amount2) / item.amount2 * 100).toFixed(2) : '0.00';
                tableHTML += `<tr ${isDuplicate ? 'class="duplicate-row"' : ''}>`;
                
                switch(id) {
                    case 'matches': tableHTML += `<td>${item.appId}</td><td>${item.amount1.toFixed(2)}</td><td>${formatDate(item.date1)}</td><td>${item.filename1}</td>`; break;
                    case 'mismatches': tableHTML += `<td>${item.appId}</td><td>${item.amount1.toFixed(2)}</td><td>${item.amount2.toFixed(2)}</td><td>${(item.amount1 - item.amount2).toFixed(2)}</td><td>${variance}%</td><td>${item.commission.toFixed(2)}</td><td>${item.tds.toFixed(2)}</td><td>${formatDate(item.date1)}</td><td>${formatDate(item.date2)}</td><td>${item.filename1}</td>`; break;
                    case 'missing2': tableHTML += `<td>${item.appId}</td><td>${item.amount1.toFixed(2)}</td><td>${item.commission.toFixed(2)}</td><td>${item.tds.toFixed(2)}</td><td>${formatDate(item.date1)}</td><td>${item.filename1}</td>`; break;
                    case 'red-alert': tableHTML += `<td>${item.appId}</td><td>${item.amount.toFixed(2)}</td><td>${item.reason}</td>`; break;
                    case 'commission-deviation': tableHTML += `<td>${item.appId}</td><td>${item.taxableValue.toFixed(2)}</td><td>${item.actualCommission.toFixed(2)}</td><td>${item.actualRate.toFixed(2)}%</td><td>${item.expectedRate.toFixed(2)}%</td><td>${item.deviation.toFixed(2)}</td>`; break;
                }
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table></div>';
            
            const total = id.includes('1') ? totalAmount2 : (id === 'red-alert' ? data.reduce((s, r) => s + r.amount, 0) : totalAmount1);
            tableHTML += `<div class="result-footer"><span>Records: ${data.length}</span> | <span>Total Amount: ${total.toFixed(2)}</span></div>`;
            
            container.innerHTML = tableHTML;
            makeTableSortable(container.querySelector('table'), data, headers, id, title);
            container.querySelector('.view-full-btn').addEventListener('click', () => openFullView(title, container.querySelector('table').outerHTML));
        }
        
        function makeTableSortable(table, data, headers, id, title) {
            const headerCells = Array.from(table.querySelectorAll('th'));
            headerCells.forEach((header) => {
                header.addEventListener('click', () => {
                    const isAsc = !header.classList.contains('asc');
                    headerCells.forEach(h => h.classList.remove('asc', 'desc'));
                    header.classList.toggle(isAsc ? 'asc' : 'desc');
                    
                    const keyMap = {
                        'appid': 'appId', 'amount': 'amount1', 's1amount': 'amount1', 's2amount': 'amount2',
                        'diff': item => item.amount1 - item.amount2, 'variance': item => item.amount1 && item.amount2 ? ((item.amount1 - item.amount2) / item.amount2) : 0,
                        'commission': 'commission', 'tds': 'tds', 'date': 'date1', 's1date': 'date1', 's2date': 'date2', 'filename': 'filename1',
                        's2amount': 'amount', 'reason': 'reason', 'taxablevalue': 'taxableValue', 'actualcommission': 'actualCommission', 
                        'actualrate': 'actualRate', 'expectedrate': 'expectedRate', 'deviation': 'deviation'
                    };
                    const key = keyMap[header.dataset.sortKey];

                    data.sort((a, b) => {
                        const valA = typeof key === 'function' ? key(a) : a[key];
                        const valB = typeof key === 'function' ? key(b) : b[key];
                        if (valA === null || valA === undefined) return 1;
                        if (valB === null || valB === undefined) return -1;
                        if (valA instanceof Date) return isAsc ? valA - valB : valB - valA;
                        if (typeof valA === 'string') return isAsc ? valA.localeCompare(valB) : valB.localeCompare(valA);
                        return isAsc ? valA - valB : valB - valA;
                    });
                    
                    buildResultTable(id, title, headers.map(h => h.innerText), data);
                });
            });
        }
        
        function openFullView(title, tableHTML) {
            const newWindow = window.open("");
            newWindow.document.write(`<html><head><title>${title}</title><style>body{font-family:sans-serif;padding:20px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ccc;padding:8px} th{background:#f0f0f0;text-align:left} .duplicate-row td{background:#fff3cd}</style></head><body><h1>${title}</h1>${tableHTML}</body></html>`);
            newWindow.document.close();
        }
        
        function renderFinancialControls() {
            const container = document.getElementById('commission-controls');
            const fileNames = Array.from(STATE.source1.files.values());
            let html = '<table class="commission-table"><thead><tr><th>Filename</th><th>Original Commission</th><th>TDS %</th><th>Additional Received</th><th>Merge To</th><th>Action</th></tr></thead><tbody>';
            
            for (const fileName of fileNames) {
                const controls = STATE.source1.financialControls[fileName];
                if (!controls) continue;
                let options = fileNames.filter(f => f !== fileName).map(f => `<option value="${f}" ${controls.mergedInto === f ? 'selected' : ''}>${f}</option>`).join('');
                
                html += `<tr>
                    <td>${fileName}</td>
                    <td>${controls.originalCommission.toFixed(2)}</td>
                    <td><input type="number" class="commission-input" data-file="${fileName}" data-field="tdsPercent" value="${controls.tdsPercent}"></td>
                    <td><input type="number" class="commission-input" data-file="${fileName}" data-field="additionalAmount" value="${controls.additionalAmount}"></td>
                    <td><select class="mapping-select merge-target" data-from-file="${fileName}"><option value="">-- No Merge --</option>${options}</select></td>
                    <td><button data-from-file="${fileName}" class="view-full-btn merge-btn" ${fileNames.length < 2 ? 'disabled' : ''}>Merge</button></td>
                </tr>`;
            }
            html += '</tbody></table>';
            container.innerHTML = html;

            container.querySelectorAll('.commission-input').forEach(el => {
                el.addEventListener('change', e => {
                    const fileName = e.target.dataset.file;
                    STATE.source1.financialControls[fileName][e.target.dataset.field] = parseFloat(e.target.value) || 0;
                });
            });
            container.querySelectorAll('.merge-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    const fromFile = e.target.dataset.fromFile;
                    const toFile = document.querySelector(`.merge-target[data-from-file="${fromFile}"]`).value;
                    updateCommissionMerge(fromFile, toFile);
                });
            });
        }
        
        function initializeFinancialControls() {
            const { data, mappings, financialControls } = STATE.source1;
            const commissionCol = mappings.commission;

            for (const fileName in financialControls) {
                const control = financialControls[fileName];
                control.originalCommission = 0;
                control.mergedCommission = 0;
            }

            for (const fileName of STATE.source1.files.values()) {
                if (!financialControls[fileName]) {
                    financialControls[fileName] = { originalCommission: 0, mergedCommission: 0, tdsPercent: 2, additionalAmount: 0, mergedInto: null };
                }
            }
            
            if (commissionCol !== undefined) {
                for (const item of data) {
                    const fileName = item.__filename;
                    if (financialControls[fileName]) {
                         financialControls[fileName].originalCommission += parseFloat(item.data[commissionCol]) || 0;
                    }
                }
            }
        }
        
        function updateCommissionMerge(fromFile, toFile) {
            const { financialControls } = STATE.source1;
            const fromControl = financialControls[fromFile];
            
            const oldTargetFile = fromControl.mergedInto;
            if(oldTargetFile && financialControls[oldTargetFile]) {
                financialControls[oldTargetFile].mergedCommission -= fromControl.originalCommission;
            }

            fromControl.mergedInto = toFile;
            if(toFile && financialControls[toFile]) {
                financialControls[toFile].mergedCommission += fromControl.originalCommission;
                alert(`Commission from ${fromFile} will now be added to ${toFile} during analysis.`);
            } else {
                 alert(`Commission from ${fromFile} will no longer be merged.`);
            }
        }

        function getFilteredData(sourceNum) {
            const { data, mappings } = STATE[`source${sourceNum}`];
            const dateFrom = document.getElementById(`date${sourceNum}-from`).valueAsDate;
            const dateTo = document.getElementById(`date${sourceNum}-to`).valueAsDate;
            const dateCol = mappings.date;

            let filteredData = data;
            if ((dateFrom || dateTo) && dateCol !== undefined) {
                filteredData = filteredData.filter(item => {
                    const dateVal = parseDate(item.data[dateCol]);
                    if (!dateVal) return false;
                    const fromOK = !dateFrom || dateVal >= dateFrom;
                    const toOK = !dateTo || dateVal <= new Date(dateTo.getTime() + 86400000);
                    return fromOK && toOK;
                });
            }
            if (sourceNum === 1) {
                const statusFilter = document.getElementById('status-filter').value;
                const statusCol = mappings.status;
                if (statusFilter !== 'all' && statusCol !== undefined) {
                    filteredData = filteredData.filter(item => (item.data[statusCol]?.toString().toLowerCase() || '') === statusFilter);
                }
            }
            return filteredData;
        }
        
        function checkForDuplicates() {
            const findDups = (data, appIdCol) => {
                if (appIdCol === undefined) return new Set();
                const appIds = new Map();
                const duplicates = new Set();
                data.forEach(item => {
                    const appId = item.data[appIdCol];
                    if(appId) {
                        if(appIds.has(appId)) duplicates.add(appId);
                        else appIds.set(appId, 1);
                    }
                });
                return duplicates;
            };

            STATE.duplicates.source1 = findDups(STATE.source1.data, STATE.source1.mappings.appId);
            STATE.duplicates.source2 = findDups(STATE.source2.data, STATE.source2.mappings.appId);

            if(STATE.duplicates.source1.size > 0 || STATE.duplicates.source2.size > 0) {
                DOM.duplicatesSection.classList.add('show');
                let html = '<ul>';
                if(STATE.duplicates.source1.size > 0) html += `<li><strong>Source 1 Duplicates:</strong> ${Array.from(STATE.duplicates.source1).join(', ')}</li>`;
                if(STATE.duplicates.source2.size > 0) html += `<li><strong>Source 2 Duplicates:</strong> ${Array.from(STATE.duplicates.source2).join(', ')}</li>`;
                html += '</ul>';
                DOM.duplicatesDisplay.innerHTML = html;
            } else {
                 DOM.duplicatesSection.classList.remove('show');
            }
        }

        function updateFileInfo(sourceNum) {
            const filesMap = STATE[`source${sourceNum}`].files;
            document.getElementById(`file-info-${sourceNum}`).innerHTML = `<b>${filesMap.size} file(s)</b> selected, <b>${STATE[`source${sourceNum}`].data.length} records</b> found.`;
            document.getElementById(`file-info-${sourceNum}`).classList.add('show');
        }

        function createColumnMappingUI(sourceNum) {
            const sourceKey = `source${sourceNum}`;
            const { headers, mappings } = STATE[sourceKey];
            const container = document.getElementById(`${sourceKey}-mappings`);
            let html = `<h4>Source ${sourceNum}</h4>`;
            for (const [key, config] of Object.entries(COLUMN_CONFIG)) {
                const options = headers.map((h, i) => `<option value="${i}" ${mappings[key] === i ? 'selected' : ''}>${h || `Column ${i+1}`}</option>`).join('');
                html += `<div class="mapping-row"><label class="mapping-label">${config.label}${config.required ? ' *' : ''}</label><select class="mapping-select" data-source="${sourceNum}" data-key="${key}"><option value="">-- Select --</option>${options}</select></div>`;
            }
            container.innerHTML = html;
            container.querySelectorAll('select').forEach(sel => sel.addEventListener('change', e => {
                const val = e.target.value;
                STATE[`source${e.target.dataset.source}`].mappings[e.target.dataset.key] = val ? parseInt(val, 10) : undefined;
                if(e.target.dataset.key === 'commission') {
                    initializeFinancialControls();
                    renderFinancialControls();
                }
                updateAnalyzeButton();
            }));
        }
        
        function updateAnalyzeButton() {
            const s1Ready = STATE.source1.files.size > 0;
            const s2Ready = STATE.source2.files.size > 0;
            let mappingsReady = false;
            if (s1Ready && s2Ready) {
                const s1Mappings = STATE.source1.mappings;
                const s2Mappings = STATE.source2.mappings;
                mappingsReady = Object.entries(COLUMN_CONFIG).every(([key, config]) => 
                    !config.required || (s1Mappings[key] !== undefined && s2Mappings[key] !== undefined)
                );
            }
            DOM.analyzeBtn.disabled = !mappingsReady;
            if (mappingsReady) DOM.analyzeBtn.textContent = 'Run Analysis';
            else if (!s1Ready || !s2Ready) DOM.analyzeBtn.textContent = 'Upload & Map Files to Begin';
            else DOM.analyzeBtn.textContent = 'Please map required columns (*)';
        }
        
        function exportResults() {
            const { matches, mismatches, missingInSource2, redAlerts, commissionDeviations } = STATE.analysisResults;
            const wb = XLSX.utils.book_new();

            const summaryData = [
                ["Category", "Record Count", "Total S1 Amount", "Total S2 Amount"],
                ["Matches", matches.length, matches.reduce((s,r)=>s+r.amount1,0), matches.reduce((s,r)=>s+r.amount2,0)],
                ["Mismatches", mismatches.length, mismatches.reduce((s,r)=>s+r.amount1,0), mismatches.reduce((s,r)=>s+r.amount2,0)],
                ["Missing in Source 2", missingInSource2.length, missingInSource2.reduce((s,r)=>s+r.amount1,0), 0],
                ["Red Alerts (Missing/Unpaid in S1)", redAlerts.length, 0, redAlerts.reduce((s,r)=>s+r.amount,0)],
            ];
            const ws_summary = XLSX.utils.aoa_to_sheet([["Reconciliation Summary"],[],...summaryData]);
            XLSX.utils.book_append_sheet(wb, ws_summary, "Summary");
            
            if (STATE.duplicates.source1.size > 0 || STATE.duplicates.source2.size > 0) {
                const dupData = [
                    ...Array.from(STATE.duplicates.source1).map(d => ({ Source: 1, 'Duplicate App ID': d })),
                    ...Array.from(STATE.duplicates.source2).map(d => ({ Source: 2, 'Duplicate App ID': d }))
                ];
                XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(dupData), "Duplicate IDs Found");
            }
            
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(redAlerts.map(r => ({'App ID':r.appId, 'Source 2 Amount':r.amount, 'Reason': r.reason}))), "Red Alerts");
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(commissionDeviations.map(r => ({'App ID':r.appId, 'Taxable Value':r.taxableValue, 'Actual Commission': r.actualCommission, 'Actual Rate %': r.actualRate, 'Expected Rate %': r.expectedRate, 'Deviation Amount': r.deviation}))), "Commission Deviations");
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(matches.map(r => ({'App ID':r.appId, 'Amount':r.amount1, 'Date': formatDate(r.date1), 'Source 1 Filename': r.filename1}))), "Matches");
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(mismatches.map(r => ({'App ID':r.appId, 'S1 Amount':r.amount1, 'S2 Amount':r.amount2, 'Difference': r.amount1 - r.amount2, 'Variance %': r.amount1 && r.amount2 ? ((r.amount1 - r.amount2) / r.amount2 * 100) : 0, 'S1 Commission': r.commission, 'TDS': r.tds, 'S1 Date': formatDate(r.date1), 'S2 Date': formatDate(r.date2), 'S1 Filename': r.filename1}))), "Mismatches");
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(missingInSource2.map(r => ({'App ID':r.appId, 'S1 Amount':r.amount1, 'S1 Commission': r.commission, 'TDS': r.tds, 'S1 Date': formatDate(r.date1), 'S1 Filename': r.filename1}))), "Missing in Source 2");
            
            const s1RawData = getFilteredData(1).map(r => {
                const taxableValue = parseFloat(r.data[STATE.source1.mappings.amount]) || 0;
                const commission = parseFloat(r.data[STATE.source1.mappings.commission]) || 0;
                const commissionRate = (taxableValue && commission) ? (commission / taxableValue) * 100 : 0;
                let rowObject = { '__filename': r.__filename };
                STATE.source1.headers.forEach((h, i) => rowObject[h] = r.data[i]);
                rowObject['Commission Rate (%)'] = commissionRate.toFixed(2);
                return rowObject;
            });
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(s1RawData), "Processed Raw Data (S1)");
            
            const commissionSummary = Object.values(s1RawData.reduce((acc, row) => {
                const rate = row['Commission Rate (%)'];
                if(!acc[rate]) acc[rate] = { 'Commission Rate (%)': rate, 'Transaction Count': 0, 'Total Taxable Value': 0, 'Total Commission': 0 };
                acc[rate]['Transaction Count']++;
                acc[rate]['Total Taxable Value'] += parseFloat(row[STATE.source1.headers[STATE.source1.mappings.amount]]) || 0;
                acc[rate]['Total Commission'] += parseFloat(row[STATE.source1.headers[STATE.source1.mappings.commission]]) || 0;
                return acc;
            }, {}));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(commissionSummary), "Commission Rate Summary");

            XLSX.writeFile(wb, `Reconciliation_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        function parseDate(date) {
            if (date instanceof Date && !isNaN(date)) return date;
            if (typeof date === 'number') {
                const excelEpoch = new Date(Date.UTC(1899, 11, 30));
                return new Date(excelEpoch.getTime() + date * 86400000);
            }
            if (typeof date === 'string') {
                const parsed = new Date(date);
                if (!isNaN(parsed)) return parsed;
            }
            return null;
        }

        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return 'N/A';
            return date.toISOString().split('T')[0];
        }
        
        function showLoading() { DOM.loadingOverlay.classList.add('show'); }
        function hideLoading() { DOM.loadingOverlay.classList.remove('show'); }

        function initialize() {
            DOM.userInfo.textContent = `User: ksismad | UTC 2025-06-19 20:31:36`;
            document.getElementById('file-input-1').addEventListener('change', e => handleFileSelection(e.target.files, 1));
            document.getElementById('file-input-2').addEventListener('change', e => handleFileSelection(e.target.files, 2));
            DOM.analyzeBtn.addEventListener('click', runAnalysis);
            DOM.exportBtn.addEventListener('click', exportResults);
        }
        
        function detectColumnMappings(headers) {
            const mappings = {};
            for (const [key, config] of Object.entries(COLUMN_CONFIG)) {
                const foundIndex = headers.findIndex(h => h && config.patterns.some(p => p.test(h)));
                if (foundIndex !== -1) mappings[key] = foundIndex;
            }
            return mappings;
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
