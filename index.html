<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced App ID Analyzer Pro</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pivot-table@1.0.0/dist/pivot.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/pivot-table@1.0.0/dist/pivot.min.css" rel="stylesheet">
  <style>
    /* [Previous CSS styles remain exactly the same] */
    /* ... */
  </style>
</head>
<body>
  <!-- [Previous HTML structure remains exactly the same] -->
  <!-- ... -->

  <script>
    // Enhanced AppState management with validation
    const AppState = (() => {
      let state = {
        source1Files: [],
        source2Files: [],
        columnMappings: {},
        analysisOptions: {
          includeCommission: false,
          applyGST: false,
          gstRound: false
        },
        analysisResults: null,
        mergedData: null,
        pivotData: null,
        rawData: null
      };

      const validateState = () => {
        const { source1Files, source2Files, columnMappings } = state;
        const required = ['appId', 'amount', 'date'];
        
        // Validate files
        if (source1Files.length === 0 || source2Files.length === 0) {
          return false;
        }
        
        // Validate column mappings
        return required.every(id => {
          const mapping = columnMappings[id];
          return mapping && 
                 mapping.source1 !== undefined && mapping.source1 !== "" && 
                 (id === 'commission' || (mapping.source2 !== undefined && mapping.source2 !== ""));
        });
      };

      return {
        getState: () => ({ ...state }),
        setState: (newState) => { 
          state = { ...state, ...newState }; 
          return validateState();
        },
        resetAnalysis: () => { 
          state.analysisResults = null;
          state.mergedData = null;
          state.pivotData = null;
          state.rawData = null;
        },
        isValid: validateState
      };
    })();

    // DOM References
    const DOM = {
      fileInput1: document.getElementById('file-input-1'),
      fileInput2: document.getElementById('file-input-2'),
      uploadBtn1: document.getElementById('upload-btn-1'),
      uploadBtn2: document.getElementById('upload-btn-2'),
      drop1: document.getElementById('drop1'),
      drop2: document.getElementById('drop2'),
      fileInfo1: document.getElementById('file-info-1'),
      fileInfo2: document.getElementById('file-info-2'),
      fileList1: document.getElementById('file-list-1'),
      mergeBtn1: document.getElementById('merge-btn-1'),
      mappingFields: document.getElementById('mapping-fields'),
      includeCommission: document.getElementById('include-commission'),
      applyGST: document.getElementById('apply-gst'),
      gstRound: document.getElementById('gst-round'),
      analyzeBtn: document.getElementById('analyze-btn'),
      resultsSection: document.getElementById('results-section'),
      results: document.getElementById('results'),
      statsGrid: document.getElementById('stats-grid'),
      loadingOverlay: document.getElementById('loading-overlay'),
      errorMessage: document.getElementById('error-message'),
      successMessage: document.getElementById('success-message'),
      userInfo: document.getElementById('user-info'),
      exportBtn: document.getElementById('export-btn'),
      exportMergedBtn: document.getElementById('export-merged-btn'),
      detailedResults: document.getElementById('detailed-results'),
      pivotContainer: document.getElementById('pivot-container'),
      pivotRows: document.getElementById('pivot-rows'),
      pivotCols: document.getElementById('pivot-cols'),
      pivotVals: document.getElementById('pivot-vals'),
      pivotAgg: document.getElementById('pivot-agg'),
      mergedResults: document.getElementById('merged-results'),
      tabs: document.querySelectorAll('.tab'),
      tabContents: document.querySelectorAll('.tab-content')
    };

    // Utility Functions with enhanced error handling
    const Utils = {
      showLoading: () => {
        DOM.loadingOverlay.style.display = 'flex';
        setTimeout(() => DOM.loadingOverlay.classList.add('show'), 10);
      },
      
      hideLoading: () => {
        DOM.loadingOverlay.classList.remove('show');
        setTimeout(() => DOM.loadingOverlay.style.display = 'none', 300);
      },
      
      showError: (msg) => {
        console.error("Error:", msg);
        DOM.errorMessage.textContent = msg;
        DOM.errorMessage.classList.add('show');
        setTimeout(() => DOM.errorMessage.classList.remove('show'), 8000);
      },
      
      showSuccess: (msg) => {
        DOM.successMessage.textContent = msg;
        DOM.successMessage.classList.add('show');
        setTimeout(() => DOM.successMessage.classList.remove('show'), 5000);
      },
      
      updateUserInfo: () => {
        const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
        DOM.userInfo.textContent = `User: ksismad | UTC ${now}`;
      },
      
      formatNumber: (num, decimals = 2) => {
        if (isNaN(num)) return 'N/A';
        return parseFloat(num.toFixed(decimals)).toLocaleString();
      },
      
      findMatch: (headers, patterns) => {
        if (!headers || !patterns) return '';
        for (let pattern of patterns) {
          const index = headers.findIndex(h => h && pattern.test(String(h)));
          if (index !== -1) return index;
        }
        return '';
      },
      
      getS1Status: (row, commissionIndex) => {
        if (commissionIndex === undefined || commissionIndex === null || commissionIndex === "") return "Unpaid";
        const commValue = row[commissionIndex];
        return (!commValue || Number(commValue) === 0) ? "Unpaid" : "Paid";
      },
      
      applyGSTToS1: (amount) => {
        if (typeof amount !== 'number') amount = parseFloat(amount) || 0;
        const { applyGST, gstRound } = AppState.getState().analysisOptions;
        if (!applyGST) return amount;
        let result = amount * 1.18;
        return gstRound ? Math.round(result) : result;
      },
      
      safeParseFloat: (value) => {
        if (typeof value === 'number') return value;
        if (typeof value === 'string') {
          const cleaned = value.replace(/[^\d.-]/g, '');
          return parseFloat(cleaned) || 0;
        }
        return 0;
      },
      
      calculateCommissionPercentage: (amount, commission) => {
        if (!amount || !commission) return 0;
        amount = Utils.safeParseFloat(amount);
        commission = Utils.safeParseFloat(commission);
        return (commission / amount) * 100;
      },
      
      generateUniqueId: () => {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
      }
    };

    // File Handling with improved error handling and parallel processing
    const FileHandler = {
      init: () => {
        // Initialize event handlers
        DOM.applyGST.onchange = function() {
          DOM.gstRound.disabled = !this.checked;
          if (!this.checked) DOM.gstRound.checked = false;
          const state = AppState.getState();
          AppState.setState({
            analysisOptions: {
              ...state.analysisOptions,
              applyGST: this.checked,
              gstRound: DOM.gstRound.checked
            }
          });
          Analyzer.updateAnalyzeBtn();
        };
        
        DOM.gstRound.onchange = () => {
          const state = AppState.getState();
          AppState.setState({
            analysisOptions: {
              ...state.analysisOptions,
              gstRound: DOM.gstRound.checked
            }
          });
        };
        
        DOM.includeCommission.onchange = () => {
          const state = AppState.getState();
          AppState.setState({
            analysisOptions: {
              ...state.analysisOptions,
              includeCommission: DOM.includeCommission.checked
            }
          });
        };
        
        // File input handlers
        DOM.uploadBtn1.onclick = e => { e.preventDefault(); DOM.fileInput1.value = ''; DOM.fileInput1.click(); };
        DOM.uploadBtn2.onclick = e => { e.preventDefault(); DOM.fileInput2.value = ''; DOM.fileInput2.click(); };
        
        DOM.fileInput1.onchange = e => { if (e.target.files.length) FileHandler.handleFileSelection(e.target.files, 1); };
        DOM.fileInput2.onchange = e => { if (e.target.files.length) FileHandler.handleFileSelection(e.target.files, 2); };
        
        // Drag and drop handlers
        [{ drop: DOM.drop1, src: 1 }, { drop: DOM.drop2, src: 2 }].forEach(o => {
          o.drop.ondragover = e => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            o.drop.classList.add('dragover'); 
          };
          
          o.drop.ondragleave = e => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            o.drop.classList.remove('dragover'); 
          };
          
          o.drop.ondrop = e => { 
            e.preventDefault(); 
            e.stopPropagation();
            o.drop.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
              FileHandler.handleFileSelection(e.dataTransfer.files, o.src);
            }
          };
        });
        
        DOM.mergeBtn1.onclick = FileHandler.showMergeDialog;
      },
      
      handleFileSelection: async (files, src) => {
        if (!files || files.length === 0) { 
          Utils.showError('No files selected'); 
          return; 
        }
        
        // Validate file count for source 2 (only 1 file allowed)
        if (src === 2 && files.length > 1) {
          Utils.showError('Source 2 can only accept one file');
          return;
        }
        
        Utils.showLoading();
        
        try {
          const fileArray = Array.from(files);
          const targetState = src === 1 ? 'source1Files' : 'source2Files';
          const fileListDOM = src === 1 ? DOM.fileList1 : null;
          const fileInfoDOM = src === 1 ? DOM.fileInfo1 : DOM.fileInfo2;
          
          // Reset previous files for this source
          AppState.setState({ [targetState]: [] });
          if (fileListDOM) fileListDOM.innerHTML = '';
          
          // Process files in parallel
          const processPromises = fileArray.map(file => 
            FileHandler.processExcelFile(file)
              .then(data => ({ file, data }))
              .catch(err => ({ file, error: err }))
          );
          
          const results = await Promise.all(processPromises);
          
          // Process results
          const successfulFiles = [];
          const failedFiles = [];
          
          results.forEach(result => {
            if (result.error) {
              failedFiles.push({ file: result.file, error: result.error });
            } else {
              successfulFiles.push({
                file: result.file,
                headers: result.data[0],
                records: result.data.slice(1),
                fileId: Utils.generateUniqueId(),
                fileName: result.file.name
              });
            }
          });
          
          // Handle failed files
          if (failedFiles.length > 0) {
            const errorMessages = failedFiles.map(f => `${f.file.name}: ${f.error.message || 'Unknown error'}`);
            Utils.showError(`Failed to process ${failedFiles.length} file(s):\n${errorMessages.join('\n')}`);
          }
          
          // Update state with successful files
          if (successfulFiles.length > 0) {
            AppState.setState({ [targetState]: successfulFiles });
            
            // Update UI
            if (fileListDOM) {
              successfulFiles.forEach(fileData => {
                const li = document.createElement('li');
                li.innerHTML = `
                  <span>${fileData.file.name}</span>
                  <span>${fileData.records.length} rows</span>
                `;
                fileListDOM.appendChild(li);
              });
            }
            
            fileInfoDOM.textContent = `${successfulFiles.length} file(s) loaded`;
            fileInfoDOM.classList.add('show');
            
            if (src === 1) {
              DOM.mergeBtn1.style.display = successfulFiles.length > 1 ? 'inline-flex' : 'none';
            }
          }
          
          // Setup column mappings if we have both sources
          ColumnMapper.setupColumnMappings();
          Analyzer.updateAnalyzeBtn();
          
        } catch (error) {
          Utils.showError(`Unexpected error: ${error.message}`);
        } finally {
          Utils.hideLoading();
        }
      },
      
      processExcelFile: (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          
          reader.onload = (e) => {
            try {
              const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
              const ws = wb.Sheets[wb.SheetNames[0]];
              const data = XLSX.utils.sheet_to_json(ws, { header: 1 });
              
              if (!data || data.length < 2) {
                reject(new Error('File has no data rows or is improperly formatted'));
                return;
              }
              
              // Clean data - remove empty rows and trim strings
              const cleanedData = data
                .filter(row => row.some(cell => cell !== undefined && cell !== null && cell !== ''))
                .map(row => row.map(cell => typeof cell === 'string' ? cell.trim() : cell));
              
              if (cleanedData.length < 2) {
                reject(new Error('File has no valid data rows after cleaning'));
                return;
              }
              
              resolve(cleanedData);
            } catch (err) {
              reject(new Error(`Error parsing file: ${err.message}`));
            }
          };
          
          reader.onerror = () => {
            reject(new Error('Error reading file'));
          };
          
          reader.readAsArrayBuffer(file);
        });
      },
      
      showMergeDialog: () => {
        const { source1Files } = AppState.getState();
        if (source1Files.length < 2) return;
        
        const fileNames = source1Files.map((f, i) => `${i + 1}. ${f.file.name} (${f.records.length} rows)`);
        const srcIdx = parseInt(prompt(`Select source file to merge FROM (1-${fileNames.length}):\n\n${fileNames.join('\n')}`)) - 1;
        if (isNaN(srcIdx) || srcIdx < 0 || srcIdx >= source1Files.length) {
          Utils.showError("Invalid source file selection");
          return;
        }
        
        const tgtIdx = parseInt(prompt(`Select target file to merge INTO (1-${fileNames.length}):\n\n${fileNames.join('\n')}`)) - 1;
        if (isNaN(tgtIdx) || tgtIdx < 0 || tgtIdx >= source1Files.length || srcIdx === tgtIdx) {
          Utils.showError("Invalid target file selection");
          return;
        }
        
        const sourceFile = source1Files[srcIdx];
        const targetFile = source1Files[tgtIdx];
        
        if (sourceFile.headers.join(',') !== targetFile.headers.join(',')) {
          Utils.showError("Files have different headers and cannot be merged.");
          return;
        }
        
        // Confirm merge
        if (!confirm(`Merge ${sourceFile.records.length} records from ${sourceFile.file.name} into ${targetFile.file.name}?`)) {
          return;
        }
        
        // Perform merge
        targetFile.records.push(...sourceFile.records);
        const updatedFiles = [...source1Files];
        updatedFiles.splice(srcIdx, 1);
        AppState.setState({ source1Files: updatedFiles });
        
        // Update UI
        DOM.fileList1.innerHTML = '';
        updatedFiles.forEach(f => {
          const li = document.createElement('li');
          li.innerHTML = `
            <span>${f.file.name}</span>
            <span>${f.records.length} rows</span>
          `;
          DOM.fileList1.appendChild(li);
        });
        
        DOM.mergeBtn1.style.display = updatedFiles.length > 1 ? 'inline-flex' : 'none';
        ColumnMapper.setupColumnMappings();
        Utils.showSuccess(`Successfully merged files. ${targetFile.file.name} now has ${targetFile.records.length} records.`);
      }
    };

    // Column Mapping with improved validation
    const ColumnMapper = {
      setupColumnMappings: () => {
        const { source1Files, source2Files } = AppState.getState();
        const s1Headers = source1Files[0]?.headers || [];
        const s2Headers = source2Files[0]?.headers || [];
        
        if (s1Headers.length === 0 || s2Headers.length === 0) {
          DOM.mappingFields.innerHTML = '<p>Please load both source files to configure column mappings.</p>';
          return;
        }
        
        const columns = [
          { id: 'appId', label: 'App ID', patterns: [/app.*id/i, /id/i, /application/i], required: true },
          { id: 'amount', label: 'Amount', patterns: [/amount/i, /total/i, /value/i, /payment/i], required: true },
          { id: 'commission', label: 'Commission (S1)', patterns: [/commiss|tds|fee|charge|deduction/i], s2: false },
          { id: 'date', label: 'Date', patterns: [/date/i, /timestamp/i, /time/i], required: true }
        ];
        
        let html = '';
        columns.forEach(col => {
          const s1Selected = Utils.findMatch(s1Headers, col.patterns);
          const s2Selected = col.s2 !== false ? Utils.findMatch(s2Headers, col.patterns) : null;
          
          html += `
            <div class="mapping-row">
              <label>${col.label}:</label>
              <select id="ms1-${col.id}" class="source-select" data-col="${col.id}" data-src="1">
                <option value="">Select S1 Column</option>
                ${s1Headers.map((h, i) => `
                  <option value="${i}" ${s1Selected === i ? 'selected' : ''}>
                    ${h || `Column ${i + 1}`}
                  </option>
                `).join('')}
              </select>
              ${col.s2 !== false ? `
                <select id="ms2-${col.id}" class="source-select" data-col="${col.id}" data-src="2">
                  <option value="">Select S2 Column</option>
                  ${s2Headers.map((h, i) => `
                    <option value="${i}" ${s2Selected === i ? 'selected' : ''}>
                      ${h || `Column ${i + 1}`}
                    </option>
                  `).join('')}
                </select>
              ` : `
                <span style="display:inline-block;width:150px;padding:8px;color:#666;font-style:italic;">
                  Not needed for S2
                </span>
              `}
            </div>
          `;
        });
        
        DOM.mappingFields.innerHTML = html;
        document.querySelectorAll('.source-select').forEach(select => {
          select.addEventListener('change', ColumnMapper.updateColumnMappings);
        });
        ColumnMapper.updateColumnMappings();
      },
      
      updateColumnMappings: () => {
        const columns = ['appId', 'amount', 'commission', 'date'];
        const mappings = {};
        
        columns.forEach(id => {
          const s1El = document.getElementById(`ms1-${id}`);
          const s2El = id !== 'commission' ? document.getElementById(`ms2-${id}`) : null;
          mappings[id] = { 
            source1: s1El ? s1El.value : '', 
            source2: s2El ? s2El.value : '' 
          };
        });
        
        AppState.setState({ columnMappings: mappings });
        Analyzer.updateAnalyzeBtn();
      }
    };

    // Analysis with improved data validation
    const Analyzer = {
      updateAnalyzeBtn: () => {
        const isValid = AppState.isValid();
        DOM.analyzeBtn.disabled = !isValid;
        DOM.analyzeBtn.textContent = isValid ? 'Analyze Data' : 'Select Files & Required Mappings';
      },
      
      analyzeData: () => {
        try {
          const { source1Files, source2Files, columnMappings, analysisOptions } = AppState.getState();
          const s2 = source2Files[0];
          
          if (source1Files.length === 0 || !s2) { 
            Utils.showError("Missing source files"); 
            return {}; 
          }
          
          // Combine all Source 1 records from all files
          const combinedS1Records = [];
          source1Files.forEach(file => {
            file.records.forEach(record => {
              combinedS1Records.push({
                ...record,
                sourceFile: file.fileName
              });
            });
          });
          
          const s2Records = s2.records;
          
          // Validate column mappings
          const idx = {
            s1: {
              appId: parseInt(columnMappings.appId.source1),
              amount: parseInt(columnMappings.amount.source1),
              date: parseInt(columnMappings.date.source1),
              commission: columnMappings.commission ? parseInt(columnMappings.commission.source1) : null
            },
            s2: {
              appId: parseInt(columnMappings.appId.source2),
              amount: parseInt(columnMappings.amount.source2),
              date: parseInt(columnMappings.date.source2)
            }
          };
          
          // Validate indices
          for (const [key, val] of Object.entries(idx.s1)) {
            if (val === null || isNaN(val)) {
              throw new Error(`Invalid S1 column mapping for ${key}`);
            }
          }
          
          for (const [key, val] of Object.entries(idx.s2)) {
            if (val === null || isNaN(val)) {
              throw new Error(`Invalid S2 column mapping for ${key}`);
            }
          }
          
          const scenarios = {
            "S1 Paid but missing in S2": [],
            "S2 Paid but missing in S1": [],
            "S2 Paid, S1 Unpaid": [],
            "S2 Paid, S1 Paid but amount different": [],
            "S2 Paid, S1 Unpaid and amount different": [],
            "Commission deviation (for S1 Paid)": [],
            "Duplicates in S1": [],
            "Duplicates in S2": []
          };
          
          // Create maps for faster lookup
          const s2Map = new Map();
          s2Records.forEach(r => {
            const appId = String(r[idx.s2.appId]);
            if (appId) s2Map.set(appId, r);
          });
          
          const s1AppIds = new Set();
          combinedS1Records.forEach(r => {
            const appId = String(r[idx.s1.appId]);
            if (appId) s1AppIds.add(appId);
          });
          
          // Count duplicates
          const s1DupMap = _.countBy(combinedS1Records, r => r[idx.s1.appId]);
          const s2DupMap = _.countBy(s2Records, r => r[idx.s2.appId]);
          
          // Prepare merged data for export
          const mergedData = [];
          const rawData = [];
          
          // Process combined S1 records
          combinedS1Records.forEach(r1 => {
            const appId = r1[idx.s1.appId];
            if (!appId) return;
            
            const r2 = s2Map.get(String(appId));
            const s1Status = Utils.getS1Status(r1, idx.s1.commission);
            
            let amount1 = Utils.safeParseFloat(r1[idx.s1.amount]);
            const preGSTAmount = amount1; // Store pre-GST amount for commission calculation
            amount1 = Utils.applyGSTToS1(amount1);
            
            // Add to merged data
            const mergedRecord = {
              AppID: appId,
              Source: 'S1',
              Status: s1Status,
              Amount: amount1,
              PreGSTAmount: preGSTAmount,
              Date: r1[idx.s1.date],
              File: r1.sourceFile,
              Commission: idx.s1.commission !== null ? Utils.safeParseFloat(r1[idx.s1.commission]) : null
            };
            
            if (mergedRecord.Commission !== null) {
              mergedRecord.CommissionPercentage = Utils.calculateCommissionPercentage(preGSTAmount, mergedRecord.Commission);
            }
            
            mergedData.push(mergedRecord);
            
            // Add to raw data for pivot
            const rawRecord = {
              AppID: appId,
              Source: 'S1',
              Status: s1Status,
              Amount: amount1,
              Date: r1[idx.s1.date],
              File: r1.sourceFile,
              Scenario: 'Normal',
              Difference: 0
            };
            
            if (r2) {
              let amount2 = Utils.safeParseFloat(r2[idx.s2.amount]);
              
              if (s1Status === "Paid") {
                if (Math.abs(amount2 - amount1) > 0.001) {
                  const scenarioRecord = { 
                    AppID: appId, 
                    S1_Amount: amount1, 
                    S2_Amount: amount2,
                    Difference: (amount2 - amount1),
                    S1_Date: r1[idx.s1.date],
                    S2_Date: r2[idx.s2.date],
                    S1_File: r1.sourceFile,
                    S2_File: s2.fileName,
                    Status: s1Status
                  };
                  scenarios["S2 Paid, S1 Paid but amount different"].push(scenarioRecord);
                  
                  // Update raw record for pivot
                  rawRecord.Scenario = "S2 Paid, S1 Paid but amount different";
                  rawRecord.Difference = amount2 - amount1;
                  rawRecord.S2_Amount = amount2;
                  rawRecord.S2_Date = r2[idx.s2.date];
                }
                
                if (analysisOptions.includeCommission && idx.s1.commission !== null) {
                  const commValue = Utils.safeParseFloat(r1[idx.s1.commission]);
                  const expectedComm = preGSTAmount * 0.02; // Calculate expected commission on pre-GST amount
                  if (Math.abs(commValue - expectedComm) > 0.01) {
                    scenarios["Commission deviation (for S1 Paid)"].push({ 
                      AppID: appId, 
                      Actual: commValue, 
                      Expected: expectedComm,
                      Difference: (commValue - expectedComm),
                      Percentage: (commValue - expectedComm) / expectedComm * 100,
                      S1_Amount: amount1,
                      S1_PreGSTAmount: preGSTAmount,
                      S1_File: r1.sourceFile,
                      Status: s1Status
                    });
                  }
                }
              } else { // S1 Unpaid
                const scenarioName = Math.abs(amount2 - amount1) > 0.001 ? 
                  "S2 Paid, S1 Unpaid and amount different" : 
                  "S2 Paid, S1 Unpaid";
                  
                const scenarioRecord = { 
                  AppID: appId, 
                  S1_Amount: amount1, 
                  S2_Amount: amount2,
                  Difference: (amount2 - amount1),
                  S1_Date: r1[idx.s1.date],
                  S2_Date: r2[idx.s2.date],
                  S1_File: r1.sourceFile,
                  S2_File: s2.fileName,
                  Status: s1Status
                };
                scenarios[scenarioName].push(scenarioRecord);
                
                // Update raw record for pivot
                rawRecord.Scenario = scenarioName;
                rawRecord.Difference = amount2 - amount1;
                rawRecord.S2_Amount = amount2;
                rawRecord.S2_Date = r2[idx.s2.date];
              }
            } else if (s1Status === "Paid") {
              const scenarioRecord = { 
                AppID: appId, 
                S1_Amount: amount1,
                S1_Date: r1[idx.s1.date],
                S1_File: r1.sourceFile,
                Status: s1Status
              };
              scenarios["S1 Paid but missing in S2"].push(scenarioRecord);
              
              // Update raw record for pivot
              rawRecord.Scenario = "S1 Paid but missing in S2";
            }
            
            if (s1DupMap[appId] > 1) {
              const scenarioRecord = { 
                AppID: appId, 
                Count: s1DupMap[appId],
                Sample_Date: r1[idx.s1.date],
                S1_File: r1.sourceFile,
                Status: s1Status
              };
              scenarios["Duplicates in S1"].push(scenarioRecord);
              
              // Update raw record for pivot
              rawRecord.Scenario = "Duplicates in S1";
            }
            
            rawData.push(rawRecord);
          });
          
          // Process S2 records
          s2Records.forEach(r2 => {
            const appId = r2[idx.s2.appId];
            if (!appId) return;
            
            // Add to merged data
            mergedData.push({
              AppID: appId,
              Source: 'S2',
              Status: 'Paid',
              Amount: Utils.safeParseFloat(r2[idx.s2.amount]),
              Date: r2[idx.s2.date],
              File: s2.fileName
            });
            
            // Add to raw data for pivot
            const rawRecord = {
              AppID: appId,
              Source: 'S2',
              Status: 'Paid',
              Amount: Utils.safeParseFloat(r2[idx.s2.amount]),
              Date: r2[idx.s2.date],
              File: s2.fileName,
              Scenario: 'Normal',
              Difference: 0
            };
            
            if (!s1AppIds.has(String(appId))) {
              const scenarioRecord = { 
                AppID: appId, 
                S2_Amount: Utils.safeParseFloat(r2[idx.s2.amount]),
                S2_Date: r2[idx.s2.date],
                S2_File: s2.fileName,
                Status: 'Paid'
              };
              scenarios["S2 Paid but missing in S1"].push(scenarioRecord);
              
              // Update raw record for pivot
              rawRecord.Scenario = "S2 Paid but missing in S1";
            }
            
            if (s2DupMap[appId] > 1) {
              const scenarioRecord = { 
                AppID: appId, 
                Count: s2DupMap[appId],
                Sample_Date: r2[idx.s2.date],
                S2_File: s2.fileName,
                Status: 'Paid'
              };
              scenarios["Duplicates in S2"].push(scenarioRecord);
              
              // Update raw record for pivot
              rawRecord.Scenario = "Duplicates in S2";
            }
            
            rawData.push(rawRecord);
          });
          
          // Deduplicate duplicate lists
          scenarios["Duplicates in S1"] = _.uniqBy(scenarios["Duplicates in S1"], 'AppID');
          scenarios["Duplicates in S2"] = _.uniqBy(scenarios["Duplicates in S2"], 'AppID');
          
          // Store merged and pivot data
          AppState.setState({ 
            mergedData: mergedData,
            pivotData: rawData,
            rawData: rawData
          });
          
          return scenarios;
        } catch (error) {
          Utils.showError(`Analysis failed: ${error.message}`);
          console.error(error);
          return {};
        }
      },
      
      displayResults: (scenarios) => {
        const orderedScenarios = [
          "S1 Paid but missing in S2", 
          "S2 Paid but missing in S1", 
          "S2 Paid, S1 Unpaid",
          "S2 Paid, S1 Paid but amount different", 
          "S2 Paid, S1 Unpaid and amount different",
          "Commission deviation (for S1 Paid)", 
          "Duplicates in S1", 
          "Duplicates in S2"
        ];
        
        // Calculate stats for summary cards
        const stats = {
          totalAlerts: 0,
          totalAmountDiscrepancies: 0,
          totalMissingRecords: 0,
          totalDuplicates: 0,
          totalAmountDifference: 0
        };
        
        orderedScenarios.forEach(scenario => {
          const records = scenarios[scenario] || [];
          stats.totalAlerts += records.length;
          
          if (scenario.includes("amount different")) {
            stats.totalAmountDiscrepancies += records.length;
            if (records[0]?.Difference) {
              stats.totalAmountDifference += records.reduce((sum, r) => sum + (r.Difference || 0), 0);
            }
          } else if (scenario.includes("missing")) {
            stats.totalMissingRecords += records.length;
          } else if (scenario.includes("Duplicates")) {
            stats.totalDuplicates += records.length;
          }
        });
        
        // Display stats cards
        DOM.statsGrid.innerHTML = `
          <div class="stat-card danger">
            <h3>Total Alerts</h3>
            <div class="stat-value">${stats.totalAlerts}</div>
            <div class="stat-subtext">Potential issues found</div>
          </div>
          <div class="stat-card warning">
            <h3>Amount Discrepancies</h3>
            <div class="stat-value">${stats.totalAmountDiscrepancies}</div>
            <div class="stat-subtext">Payment amount mismatches</div>
          </div>
          <div class="stat-card info">
            <h3>Missing Records</h3>
            <div class="stat-value">${stats.totalMissingRecords}</div>
            <div class="stat-subtext">Records in one source only</div>
          </div>
          <div class="stat-card ${stats.totalAmountDifference >= 0 ? 'success' : 'danger'}">
            <h3>Net Amount Difference</h3>
            <div class="stat-value">${Utils.formatNumber(stats.totalAmountDifference)}</div>
            <div class="stat-subtext">S2 vs S1 total difference</div>
          </div>
        `;
        
        // Display detailed results in summary view
        let html = '';
        orderedScenarios.forEach(scenarioName => {
          const records = scenarios[scenarioName] || [];
          const isEmpty = records.length === 0;
          let boxClass = 'alert-box';
          
          if (scenarioName.includes("missing in S2")) boxClass += ' danger';
          else if (scenarioName.includes("missing in S1")) boxClass += ' warning';
          else if (scenarioName.includes("Unpaid")) boxClass += ' info';
          else if (scenarioName.includes("Commission")) boxClass += ' info';
          else if (scenarioName.includes("Duplicates")) boxClass += ' warning';
          
          if (isEmpty) boxClass += ' empty';
          
          html += `<div class="${boxClass}">
                     <div class="alert-title">${scenarioName}</div>
                     <div class="alert-count">${records.length} records</div>`;
          
          if (!isEmpty) {
            html += `<table class="alert-table"><thead><tr>`;
            const headers = Object.keys(records[0]).filter(h => !['S1_File', 'S2_File', 'Status'].includes(h));
            headers.forEach(h => { 
              const displayName = h.replace(/_/g, ' ').replace('S1 ', 'S1 ').replace('S2 ', 'S2 ');
              html += `<th>${displayName}</th>`; 
            });
            html += `</tr></thead><tbody>`;
            
            records.slice(0, 5).forEach(record => {
              html += `<tr>`;
              headers.forEach(h => {
                let value = record[h];
                let cellClass = '';
                
                if (typeof value === 'number') {
                  value = h.includes('Amount') || h.includes('Difference') || h === 'Percentage' ? 
                    Utils.formatNumber(value) : 
                    value.toString();
                  
                  if (h === 'Difference' || h === 'Percentage') {
                    cellClass = 'amount-cell' + (value < 0 ? ' negative' : ' positive');
                  } else if (h.includes('Amount')) {
                    cellClass = 'amount-cell';
                  }
                }
                
                if (h === 'AppID') {
                  value = value || 'N/A';
                }
                
                html += `<td class="${cellClass}">${value || 'N/A'}</td>`;
              });
              html += `</tr>`;
            });
            
            html += `</tbody></table>`;
            if (records.length > 5) {
              html += `<div style="margin-top:0.5rem;font-size:0.85rem;color:var(--gray-500);">
                        + ${records.length - 5} more records
                      </div>`;
            }
          } else {
            html += `<div style="color:var(--gray-500);font-style:italic;margin-top:0.5rem;">
                      No records found
                    </div>`;
          }
          html += `</div>`;
        });
        
        DOM.results.innerHTML = html;
        
        // Display full detailed results in detailed view
        let detailedHtml = '';
        orderedScenarios.forEach(scenarioName => {
          const records = scenarios[scenarioName] || [];
          if (records.length === 0) return;
          
          detailedHtml += `<h3 style="margin-top:2rem;color:var(--gray-700);">${scenarioName} (${records.length} records)</h3>`;
          detailedHtml += `<div class="source-file-info">Source files: ${_.uniq(records.map(r => r.S1_File || r.S2_File)).join(', ')}</div>`;
          detailedHtml += `<div style="overflow-x:auto;"><table class="alert-table"><thead><tr>`;
          
          const headers = Object.keys(records[0]);
          headers.forEach(h => { 
            const displayName = h.replace(/_/g, ' ').replace('S1 ', 'S1 ').replace('S2 ', 'S2 ');
            detailedHtml += `<th>${displayName}</th>`; 
          });
          
          detailedHtml += `</tr></thead><tbody>`;
          
          records.forEach(record => {
            detailedHtml += `<tr>`;
            headers.forEach(h => {
              let value = record[h];
              let cellClass = '';
              
              if (typeof value === 'number') {
                value = h.includes('Amount') || h.includes('Difference') || h === 'Percentage' ? 
                  Utils.formatNumber(value) : 
                  value.toString();
                
                if (h === 'Difference' || h === 'Percentage') {
                  cellClass = 'amount-cell' + (value < 0 ? ' negative' : ' positive');
                } else if (h.includes('Amount')) {
                  cellClass = 'amount-cell';
                }
              }
              
              if (h === 'Status') {
                cellClass = value === 'Paid' ? 'paid-cell' : 'unpaid-cell';
              }
              
              if (h === 'AppID') {
                value = value || 'N/A';
              }
              
              detailedHtml += `<td class="${cellClass}">${value || 'N/A'}</td>`;
            });
            detailedHtml += `</tr>`;
          });
          
          detailedHtml += `</tbody></table></div>`;
        });
        
        DOM.detailedResults.innerHTML = detailedHtml;
        
        // Display merged data view
        const { mergedData } = AppState.getState();
        if (mergedData && mergedData.length > 0) {
          let mergedHtml = `<div style="margin-bottom:1rem;">
                              <strong>Total Records:</strong> ${mergedData.length} 
                              (S1: ${mergedData.filter(d => d.Source === 'S1').length}, 
                              S2: ${mergedData.filter(d => d.Source === 'S2').length})
                            </div>`;
          
          mergedHtml += `<div style="overflow-x:auto;"><table class="alert-table"><thead><tr>
                          <th>App ID</th>
                          <th>Source</th>
                          <th>Status</th>
                          <th>Amount</th>
                          <th>Date</th>
                          <th>File</th>
                          <th>Commission</th>
                          <th>Commission %</th>
                        </tr></thead><tbody>`;
          
          mergedData.slice(0, 100).forEach(record => {
            mergedHtml += `<tr>
                            <td>${record.AppID || 'N/A'}</td>
                            <td>${record.Source}</td>
                            <td class="${record.Status === 'Paid' ? 'paid-cell' : 'unpaid-cell'}">${record.Status}</td>
                            <td class="amount-cell">${Utils.formatNumber(record.Amount)}</td>
                            <td>${record.Date || 'N/A'}</td>
                            <td>${record.File || 'N/A'}</td>
                            <td class="amount-cell">${record.Commission !== null ? Utils.formatNumber(record.Commission) : 'N/A'}</td>
                            <td class="amount-cell">${record.CommissionPercentage !== undefined ? Utils.formatNumber(record.CommissionPercentage) + '%' : 'N/A'}</td>
                          </tr>`;
          });
          
          if (mergedData.length > 100) {
            mergedHtml += `<tr>
                            <td colspan="8" style="text-align:center;padding:1rem;color:var(--gray-500);">
                              + ${mergedData.length - 100} more records
                            </td>
                          </tr>`;
          }
          
          mergedHtml += `</tbody></table></div>`;
          DOM.mergedResults.innerHTML = mergedHtml;
        }
        
        // Update pivot view
        Analyzer.updatePivotView();
        
        // Show results section
        DOM.resultsSection.style.display = 'block';
        DOM.resultsSection.scrollIntoView({ behavior: 'smooth' });
        
        // Store results for export
        AppState.setState({ analysisResults: scenarios });
        Utils.showSuccess("Analysis completed successfully");
      },
      
      updatePivotView: () => {
        const { pivotData } = AppState.getState();
        if (!pivotData || pivotData.length === 0) {
          DOM.pivotContainer.innerHTML = '<div class="alert-box empty">No data available for pivot analysis</div>';
          return;
        }
        
        const rows = DOM.pivotRows.value;
        const cols = DOM.pivotCols.value || null;
        const vals = DOM.pivotVals.value;
        const aggregator = DOM.pivotAgg.value.toLowerCase();
        
        try {
          // Clear previous pivot table
          DOM.pivotContainer.innerHTML = '';
          
          // Create pivot table
          pivotUI(pivotData, {
            rows: [rows],
            cols: cols ? [cols] : [],
            vals: [vals],
            aggregator: aggregator,
            rendererName: "Table",
            derivedAttributes: {
              "Amount Difference": record => record.Difference || 0
            }
          }, DOM.pivotContainer);
          
          // Ensure the pivot table is visible
          DOM.pivotContainer.style.display = 'block';
        } catch (error) {
          console.error("Pivot table error:", error);
          DOM.pivotContainer.innerHTML = `<div class="error-message show">Error generating pivot table: ${error.message}</div>`;
        }
      },
      
      exportResults: () => {
        const { analysisResults, mergedData, rawData } = AppState.getState();
        if (!analysisResults || !mergedData || !rawData) {
          Utils.showError("No analysis results to export. Please analyze data first.");
          return;
        }
        
        Utils.showLoading();
        
        try {
          const wb = XLSX.utils.book_new();
          
          // 1. Export analysis results by scenario
          Object.entries(analysisResults).forEach(([scenario, records]) => {
            if (records.length > 0) {
              const formattedRecords = records.map(record => {
                const formatted = { ...record };
                Object.keys(formatted).forEach(key => {
                  if (typeof formatted[key] === 'number') {
                    if (key.includes('Amount') || key.includes('Difference') || key === 'Percentage') {
                      formatted[key] = Utils.formatNumber(formatted[key]);
                    }
                  }
                });
                return formatted;
              });
              
              const ws = XLSX.utils.json_to_sheet(formattedRecords);
              XLSX.utils.book_append_sheet(wb, ws, scenario.substring(0, 31));
            }
          });
          
          // 2. Add summary sheet
          const summaryData = Object.entries(analysisResults).map(([scenario, records]) => ({
            Scenario: scenario,
            Count: records.length,
            Source_Files: _.uniq(records.map(r => r.S1_File || r.S2_File)).join(', ')
          }));
          
          if (summaryData.length > 0) {
            const ws = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, ws, "Summary");
          }
          
          // 3. Add merged data sheet
          const formattedMerged = mergedData.map(record => ({
            ...record,
            Amount: Utils.formatNumber(record.Amount),
            Commission: record.Commission !== null ? Utils.formatNumber(record.Commission) : null,
            CommissionPercentage: record.CommissionPercentage !== undefined ? 
              Utils.formatNumber(record.CommissionPercentage) + '%' : null
          }));
          
          const wsMerged = XLSX.utils.json_to_sheet(formattedMerged);
          XLSX.utils.book_append_sheet(wb, wsMerged, "Merged_Data");
          
          // 4. Add raw data for pivot analysis
          const formattedRaw = rawData.map(record => ({
            ...record,
            Amount: Utils.formatNumber(record.Amount),
            Difference: Utils.formatNumber(record.Difference || 0)
          }));
          
          const wsRaw = XLSX.utils.json_to_sheet(formattedRaw);
          XLSX.utils.book_append_sheet(wb, wsRaw, "Raw_Data");
          
          // Generate filename with timestamp
          const now = new Date();
          const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `AppID_Analysis_${timestamp}.xlsx`;
          
          // Export the workbook
          XLSX.writeFile(wb, filename);
          Utils.showSuccess(`Results exported successfully to ${filename}`);
        } catch (error) {
          Utils.showError(`Export failed: ${error.message}`);
          console.error(error);
        } finally {
          Utils.hideLoading();
        }
      },
      
      exportMergedData: () => {
        const { mergedData } = AppState.getState();
        if (!mergedData || mergedData.length === 0) {
          Utils.showError("No merged data to export. Please analyze data first.");
          return;
        }
        
        Utils.showLoading();
        
        try {
          const wb = XLSX.utils.book_new();
          
          // Format merged data with proper number formatting
          const formattedMerged = mergedData.map(record => ({
            AppID: record.AppID,
            Source: record.Source,
            Status: record.Status,
            Amount: Utils.formatNumber(record.Amount),
            PreGSTAmount: record.PreGSTAmount ? Utils.formatNumber(record.PreGSTAmount) : '',
            Date: record.Date,
            File: record.File,
            Commission: record.Commission !== null ? Utils.formatNumber(record.Commission) : null,
            CommissionPercentage: record.CommissionPercentage !== undefined ? 
              `${Utils.formatNumber(record.CommissionPercentage)}%` : null
          }));
          
          const ws = XLSX.utils.json_to_sheet(formattedMerged);
          XLSX.utils.book_append_sheet(wb, ws, "Merged_Data");
          
          // Add summary sheet
          const summaryData = [
            { Metric: "Total Records", Value: mergedData.length },
            { Metric: "S1 Records", Value: mergedData.filter(d => d.Source === 'S1').length },
            { Metric: "S2 Records", Value: mergedData.filter(d => d.Source === 'S2').length },
            { Metric: "Paid Records", Value: mergedData.filter(d => d.Status === 'Paid').length },
            { Metric: "Unpaid Records", Value: mergedData.filter(d => d.Status === 'Unpaid').length },
            { Metric: "Total Amount (S1)", Value: Utils.formatNumber(mergedData.filter(d => d.Source === 'S1').reduce((sum, r) => sum + r.Amount, 0)) },
            { Metric: "Total Amount (S2)", Value: Utils.formatNumber(mergedData.filter(d => d.Source === 'S2').reduce((sum, r) => sum + r.Amount, 0)) }
          ];
          
          const wsSummary = XLSX.utils.json_to_sheet(summaryData);
          XLSX.utils.book_append_sheet(wb, wsSummary, "Summary");
          
          // Generate filename with timestamp
          const now = new Date();
          const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `AppID_Merged_Data_${timestamp}.xlsx`;
          
          // Export the workbook
          XLSX.writeFile(wb, filename);
          Utils.showSuccess(`Merged data exported successfully to ${filename}`);
        } catch (error) {
          Utils.showError(`Export failed: ${error.message}`);
          console.error(error);
        } finally {
          Utils.hideLoading();
        }
      }
    };

    // Initialize the application with error handling
    document.addEventListener('DOMContentLoaded', () => {
      try {
        FileHandler.init();
        Utils.updateUserInfo();
        setInterval(Utils.updateUserInfo, 15000);
        
        DOM.analyzeBtn.addEventListener('click', async () => {
          Utils.showLoading();
          try {
            const results = Analyzer.analyzeData();
            Analyzer.displayResults(results);
          } catch (error) {
            Utils.showError(`Analysis failed: ${error.message}`);
            console.error(error);
          } finally {
            Utils.hideLoading();
          }
        });
        
        DOM.exportBtn.addEventListener('click', Analyzer.exportResults);
        
        DOM.exportMergedBtn.addEventListener('click', Analyzer.exportMergedData);
        
        // Tab switching
        DOM.tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            
            // Update active tab
            DOM.tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Show corresponding content
            DOM.tabContents.forEach(content => {
              content.classList.remove('active');
              if (content.id === `${tabName}-view`) {
                content.classList.add('active');
              }
            });
            
            // Update pivot view if pivot tab is selected
            if (tabName === 'pivot') {
              Analyzer.updatePivotView();
            }
          });
        });
        
        // Pivot controls change handlers
        [DOM.pivotRows, DOM.pivotCols, DOM.pivotVals, DOM.pivotAgg].forEach(control => {
          control.addEventListener('change', Analyzer.updatePivotView);
        });
        
        console.log("Advanced App ID Analyzer Pro Initialized");
      } catch (error) {
        console.error("Initialization error:", error);
        Utils.showError(`Application initialization failed: ${error.message}`);
      }
    });
  </script>
</body>
</html>
