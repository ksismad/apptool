<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>App ID Analyzer - Complete Analysis System</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <style>
    /* Use your existing CSS for brevity, or request a modernized version */
    .export-section {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 32px;
      flex-wrap: wrap;
    }
    .export-btn {
      padding: 12px 24px;
      background: #059669;
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .export-btn:hover {
      background: #047857;
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="user-info" id="user-info"></div>
      <h1>üîç App ID Analyzer</h1>
      <p>Advanced multi-file Excel analysis with sorting, full-view, and comprehensive reporting.</p>
    </div>
    <div class="main-content">
      <div class="upload-section">
        <div class="upload-box" id="upload-box-1">
          <h3>üìÅ Source 1 Files</h3>
          <p>Select one or more Excel files</p>
          <div class="file-input-wrapper">
            <input type="file" id="file-input-1" class="file-input" multiple accept=".xlsx,.xls">
            <button class="upload-btn" id="upload-btn-1" type="button">Choose Source 1 Files</button>
          </div>
          <div id="file-info-1" class="file-info hidden"></div>
        </div>
        <div class="upload-box" id="upload-box-2">
          <h3>üìÅ Source 2 File</h3>
          <p>Select a single Excel file</p>
          <div class="file-input-wrapper">
            <input type="file" id="file-input-2" class="file-input" accept=".xlsx,.xls">
            <button class="upload-btn" id="upload-btn-2" type="button">Choose Source 2 File</button>
          </div>
          <div id="file-info-2" class="file-info hidden"></div>
        </div>
      </div>
      <div id="dynamic-cols-1"></div>
      <div id="dynamic-cols-2"></div>
      <div id="validation-status" class="section">
        <h3 class="section-title">üìã Validation Status</h3>
        <div id="validation-items"></div>
      </div>
      <button id="analyze-btn" class="analyze-btn" disabled>Please complete setup</button>
      <div id="error-container"></div>
      <div id="results" class="results hidden"></div>
      <div class="export-section hidden" id="export-section">
        <button class="export-btn" id="export-excel-btn">Export Report (Excel)</button>
      </div>
    </div>
  </div>
  <div id="loading-overlay" class="loading-overlay hidden">
    <div class="loading-spinner" aria-label="Loading..."></div>
    <p>Processing data, please wait...</p>
  </div>
  <script>
    // --- GLOBAL STATE ---
    const STATE = {
      source1Files: [],
      source2File: null,
      isProcessing: false,
      results: null,
      exportRows: [],
    };

    // --- DOM ELEMENTS ---
    const DOM = {
      fileInput1: document.getElementById('file-input-1'),
      fileInput2: document.getElementById('file-input-2'),
      uploadBtn1: document.getElementById('upload-btn-1'),
      uploadBtn2: document.getElementById('upload-btn-2'),
      fileInfo1: document.getElementById('file-info-1'),
      fileInfo2: document.getElementById('file-info-2'),
      dynamicCols1: document.getElementById('dynamic-cols-1'),
      dynamicCols2: document.getElementById('dynamic-cols-2'),
      analyzeBtn: document.getElementById('analyze-btn'),
      errorContainer: document.getElementById('error-container'),
      results: document.getElementById('results'),
      loadingOverlay: document.getElementById('loading-overlay'),
      validationItems: document.getElementById('validation-items'),
      userInfo: document.getElementById('user-info'),
      exportSection: document.getElementById('export-section'),
      exportExcelBtn: document.getElementById('export-excel-btn'),
    };

    // --- UTILS ---
    function showError(msg, timeout = 0) {
      DOM.errorContainer.innerHTML = `<div class="error-msg" role="alert">${sanitizeHtml(msg)}</div>`;
      if (timeout > 0) setTimeout(() => DOM.errorContainer.innerHTML = '', timeout);
    }
    function showSuccess(msg, timeout = 2500) {
      DOM.errorContainer.innerHTML = `<div class="success-msg" role="alert">${sanitizeHtml(msg)}</div>`;
      if (timeout > 0) setTimeout(() => DOM.errorContainer.innerHTML = '', timeout);
    }
    function sanitizeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    function showLoading() {
      STATE.isProcessing = true;
      DOM.loadingOverlay.classList.remove('hidden');
      updateValidation();
    }
    function hideLoading() {
      STATE.isProcessing = false;
      DOM.loadingOverlay.classList.add('hidden');
      updateValidation();
    }

    // --- HEADER DETECTION ---
    const HEADER_MAP = [
      { key: 'appId', labels: [/app\s*id/i, /application\s*id/i, /^id$/i, /appid/i, /applicant id/i] },
      { key: 'amount', labels: [/amount/i, /total/i, /amt/i, /price/i, /fee/i, /cost/i, /paid amount/i, /payment/i, /value/i, /rs/i, /inr/i, /‚Çπ/i, /\$/i] },
      { key: 'date', labels: [/date/i, /created/i, /timestamp/i, /txn\s*date/i, /order date/i] },
      { key: 'paid', labels: [/paid/i, /status/i, /payment\s*status/i, /state/i, /is\s*paid/i] },
      // Add commission detection for source 1 (must always be present in source 1)
      { key: 'commission', labels: [/commission/i, /comm/i, /brokerage/i, /agent fee/i, /agent comm/i] }
    ];
    function autoDetectCols(headers) {
      const cols = {};
      headers = headers.map(h => String(h).trim());
      for (const {key, labels} of HEADER_MAP) {
        cols[key] = null;
        for (let i = 0; i < headers.length; ++i) {
          let normalized = headers[i].replace(/\s+/g, ' ').toLowerCase();
          if (labels.some(re => re.test(normalized))) {
            cols[key] = i;
            break;
          }
        }
      }
      return cols;
    }

    // --- COLUMN SELECTOR UI ---
    function renderColSelector(headers, cols, container, fileIdx, isSource1) {
      if (!headers || headers.length === 0) return;
      let html = '<div class="options-grid">';
      for (const {key} of HEADER_MAP) {
        if (key === 'commission' && !isSource1) continue; // Commission only for source 1
        html += `<div class="option-group">
          <label class="option-label" for="col-${key}-${fileIdx}">${key.charAt(0).toUpperCase()+key.slice(1)} Column${(key==='appId'||key==='amount'||(key==='commission'&&isSource1))?' *':''}</label>
          <select class="col-select" id="col-${key}-${fileIdx}" data-key="${key}" data-fileidx="${fileIdx}" data-source="${isSource1?'1':'2'}">
            <option value="">Select...</option>
            ${headers.map((h,i) =>
              `<option value="${i}" ${cols[key]===i?'selected':''}>${sanitizeHtml(h)}</option>`
            ).join('')}
          </select>
        </div>`;
      }
      html += '</div>';
      container.innerHTML = html;
      HEADER_MAP.forEach(({key})=>{
        if (key === 'commission' && !isSource1) return;
        const sel = container.querySelector(`#col-${key}-${fileIdx}`);
        sel.addEventListener('change', (e) => {
          const idx = Number(e.target.value);
          if (isSource1) {
            STATE.source1Files[fileIdx].cols[key] = isNaN(idx)?null:idx;
          } else {
            STATE.source2File.cols[key] = isNaN(idx)?null:idx;
          }
          updateValidation();
        });
      });
    }

    // --- FILE PROCESSING ---
    function processFile(file, cb) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const wb = XLSX.read(e.target.result, {type: 'array', cellDates: true});
          const ws = wb.Sheets[wb.SheetNames[0]];
          const data = XLSX.utils.sheet_to_json(ws, {header: 1, raw: false, cellDates: true});
          const headers = data[0] || [];
          const cols = autoDetectCols(headers);
          cb(null, {file, headers, data, cols});
        } catch (err) {
          cb(err);
        }
      };
      reader.onerror = () => cb(new Error('File read error'));
      reader.readAsArrayBuffer(file);
    }

    // --- FILE INPUT HANDLERS ---
    DOM.uploadBtn1.addEventListener('click',()=>DOM.fileInput1.click());
    DOM.uploadBtn2.addEventListener('click',()=>DOM.fileInput2.click());

    DOM.fileInput1.addEventListener('change', () => {
      const files = Array.from(DOM.fileInput1.files);
      if (!files.length) return;
      STATE.source1Files = [];
      let processed = 0;
      showLoading();
      files.forEach((file, idx) => {
        processFile(file, (err, res) => {
          processed++;
          if (err) showError(`Source 1 file "${file.name}": ${err.message}`);
          else {
            STATE.source1Files.push({...res, branding: String.fromCharCode(65+idx)});
          }
          if (processed === files.length) {
            hideLoading();
            updateFileInfo();
            renderColSelectorForSource1();
            updateValidation();
          }
        });
      });
    });

    DOM.fileInput2.addEventListener('change', () => {
      const file = DOM.fileInput2.files[0];
      if (!file) return;
      showLoading();
      processFile(file, (err, res) => {
        hideLoading();
        if (err) showError(`Source 2 file: ${err.message}`);
        else {
          STATE.source2File = res;
          updateFileInfo();
          renderColSelectorForSource2();
          updateValidation();
        }
      });
    });

    function updateFileInfo() {
      if (STATE.source1Files.length) {
        DOM.fileInfo1.textContent = `${STATE.source1Files.length} file(s): ${STATE.source1Files.map(f=>f.file.name).join(', ')}`;
        DOM.fileInfo1.classList.remove('hidden');
      } else {
        DOM.fileInfo1.classList.add('hidden');
      }
      if (STATE.source2File) {
        DOM.fileInfo2.textContent = STATE.source2File.file.name;
        DOM.fileInfo2.classList.remove('hidden');
      } else {
        DOM.fileInfo2.classList.add('hidden');
      }
    }

    function renderColSelectorForSource1() {
      DOM.dynamicCols1.innerHTML = STATE.source1Files.map((f, i) =>
        `<div class="section"><h4>Source 1 File: ${sanitizeHtml(f.file.name)}</h4><div id="col-sel-s1-${i}"></div></div>`
      ).join('');
      STATE.source1Files.forEach((f,i)=>{
        renderColSelector(f.headers, f.cols, DOM.dynamicCols1.querySelector(`#col-sel-s1-${i}`), i, true);
      });
    }
    function renderColSelectorForSource2() {
      if (!STATE.source2File) {DOM.dynamicCols2.innerHTML=''; return;}
      DOM.dynamicCols2.innerHTML = `<div class="section"><h4>Source 2 File: ${sanitizeHtml(STATE.source2File.file.name)}</h4><div id="col-sel-s2"></div></div>`;
      renderColSelector(STATE.source2File.headers, STATE.source2File.cols, DOM.dynamicCols2.querySelector('#col-sel-s2'), 0, false);
    }

    // --- DUPLICATE FILE DATA DETECTION ---
    function fileAppIdFingerprint(fileObj, cols) {
      if (!fileObj || !cols || cols.appId == null) return '';
      return fileObj.data.slice(1)
        .map(row => row && row[cols.appId] != null ? String(row[cols.appId]).trim() : '')
        .join('|');
    }

    // --- VALIDATION ---
    function updateValidation() {
      const hasSrc1 = STATE.source1Files.length > 0;
      const hasSrc2 = !!STATE.source2File;
      // Require commission column for source 1
      const src1ColsOk = hasSrc1 && STATE.source1Files.every(f=>
        f.cols.appId!==null && f.cols.amount!==null && f.cols.commission!==null
      );
      const src2ColsOk = hasSrc2 && STATE.source2File.cols.appId!==null && STATE.source2File.cols.amount!==null;

      // Duplicate file content detection for Source 1
      let duplicateDataFilesMsg = '';
      if (hasSrc1) {
        const seen = new Map();
        STATE.source1Files.forEach((f, idx) => {
          const fp = fileAppIdFingerprint(f, f.cols);
          if (fp && seen.has(fp)) {
            duplicateDataFilesMsg = `‚ö†Ô∏è Source 1 files "${f.file.name}" and "${seen.get(fp)}" contain identical App ID data in the same order.`;
          } else if (fp) {
            seen.set(fp, f.file.name);
          }
        });
      }
      // Duplicate file content detection for Source 2 vs Source 1
      let duplicateDataSrc2Msg = '';
      if (hasSrc2 && hasSrc1) {
        const fp2 = fileAppIdFingerprint(STATE.source2File, STATE.source2File.cols);
        STATE.source1Files.forEach(f => {
          const fp1 = fileAppIdFingerprint(f, f.cols);
          if (fp1 && fp2 && fp1 === fp2) {
            duplicateDataSrc2Msg = `‚ö†Ô∏è Source 2 file "${STATE.source2File.file.name}" contains identical App ID data as Source 1 file "${f.file.name}" in the same order.`;
          }
        });
      }

      DOM.validationItems.innerHTML = [
        {text: `Source 1 files selected (${STATE.source1Files.length})`, valid: hasSrc1},
        {text: 'Source 2 file selected', valid: hasSrc2},
        {text: 'Source 1 columns configured', valid: src1ColsOk},
        {text: 'Source 2 columns configured', valid: src2ColsOk},
      ].map(item=>
        `<div class="validation-item ${item.valid?'valid':'invalid'}">${item.text}</div>`
      ).join('') +
      (duplicateDataFilesMsg
        ? `<div class="validation-item invalid" style="color:#c2410c;">${sanitizeHtml(duplicateDataFilesMsg)}</div>`
        : '') +
      (duplicateDataSrc2Msg
        ? `<div class="validation-item invalid" style="color:#c2410c;">${sanitizeHtml(duplicateDataSrc2Msg)}</div>`
        : '');

      const canAnalyze = hasSrc1 && hasSrc2 && src1ColsOk && src2ColsOk && !duplicateDataFilesMsg && !duplicateDataSrc2Msg;
      DOM.analyzeBtn.disabled = !canAnalyze || STATE.isProcessing;
      DOM.analyzeBtn.textContent = STATE.isProcessing ? '‚è≥ Processing...' : (canAnalyze ? 'üîç Analyze Data' : 'üìã Please complete setup');
    }

    // --- ANALYSIS LOGIC ---
    DOM.analyzeBtn.addEventListener('click', () => {
      showLoading();
      setTimeout(() => {
        let s1data = [], s2data = [];
        STATE.source1Files.forEach((f, idx) => {
          s1data = s1data.concat(processFileRows(f, f.cols, f.branding));
        });
        s2data = processFileRows(STATE.source2File, STATE.source2File.cols, "S2");

        // Index S2 by App ID for quick lookup
        const s2Index = Object.create(null);
        for (const row of s2data) {
          if (!s2Index[row.appId]) s2Index[row.appId] = [];
          s2Index[row.appId].push(row);
        }

        // Find matches, missing, duplicates
        const matched = [], missingInS2 = [], duplicatesS1 = [], duplicatesS2 = [];
        const seenS1 = new Set(), seenS2 = new Set();
        const s1AppIdCount = {}, s2AppIdCount = {};

        for (const row of s1data) {
          s1AppIdCount[row.appId] = (s1AppIdCount[row.appId] || 0) + 1;
          if (s1AppIdCount[row.appId] > 1) duplicatesS1.push(row);
          if (s2Index[row.appId]) {
            const s2rows = s2Index[row.appId];
            for (const s2row of s2rows) {
              matched.push({...row, matchedWith: s2row});
              seenS2.add(s2row);
            }
          } else {
            missingInS2.push(row);
          }
          seenS1.add(row);
        }
        for (const row of s2data) {
          s2AppIdCount[row.appId] = (s2AppIdCount[row.appId] || 0) + 1;
          if (s2AppIdCount[row.appId] > 1) duplicatesS2.push(row);
        }
        const missingInS1 = s2data.filter(row => !s1data.find(r => r.appId === row.appId));

        // Totals for money impact and commission
        const sum = arr => arr.reduce((s, r) => s + (r.amount || 0), 0);
        const commissionSum = arr => arr.reduce((s, r) => s + (r.commission || 0), 0);
        const stats = {
          matched: matched.length,
          matchedAmount: sum(matched),
          missingInS2: missingInS2.length,
          missingInS2Amount: sum(missingInS2),
          missingInS1: missingInS1.length,
          missingInS1Amount: sum(missingInS1),
          duplicatesS1: duplicatesS1.length,
          duplicatesS1Amount: sum(duplicatesS1),
          duplicatesS2: duplicatesS2.length,
          duplicatesS2Amount: sum(duplicatesS2),
          totalS1: s1data.length,
          totalS1Amount: sum(s1data),
          totalS2: s2data.length,
          totalS2Amount: sum(s2data),
          totalCommission: commissionSum(s1data),
          avgCommissionPct: s1data.length ? (commissionSum(s1data) / sum(s1data)) * 100 : 0
        };

        // Prepare export rows
        STATE.exportRows = [
          ["Reconciliation Summary"],
          ["Metric","Count","Amount","Commission %"],
          ["Matched", stats.matched, stats.matchedAmount, ""],
          ["Missing in Source 2", stats.missingInS2, stats.missingInS2Amount, ""],
          ["Missing in Source 1", stats.missingInS1, stats.missingInS1Amount, ""],
          ["Duplicates in Source 1", stats.duplicatesS1, stats.duplicatesS1Amount, ""],
          ["Duplicates in Source 2", stats.duplicatesS2, stats.duplicatesS2Amount, ""],
          ["Total Commission (Source 1)", "", stats.totalCommission, stats.avgCommissionPct.toFixed(2)+"%"],
          [],
          ["Details"],
          ["Type","App ID","Amount","Commission","Commission %","Branding","Source"],
        ];
        missingInS2.forEach(r => STATE.exportRows.push(["Missing in Source 2", r.appId, r.amount, r.commission||"", r.commissionPct||"", r.branding, "S1"]));
        duplicatesS1.forEach(r => STATE.exportRows.push(["Duplicate in Source 1", r.appId, r.amount, r.commission||"", r.commissionPct||"", r.branding, "S1"]));
        missingInS1.forEach(r => STATE.exportRows.push(["Missing in Source 1", r.appId, r.amount, "", "", r.branding, "S2"]));
        duplicatesS2.forEach(r => STATE.exportRows.push(["Duplicate in Source 2", r.appId, r.amount, "", "", r.branding, "S2"]));

        // Render results
        DOM.results.innerHTML = `
          <div class="results-header">
            <div class="results-title">üîé Data Reconciliation Summary</div>
            <div class="results-meta">Report generated at UTC ${new Date().toISOString().slice(0,19).replace('T',' ')}</div>
          </div>
          <div class="stats-grid">
            <div class="stat-card success">
              <div class="stat-number">${stats.matched}</div>
              <div class="stat-label">Matched Entries</div>
              <div class="stat-meta">Total Amount: ‚Çπ${stats.matchedAmount.toLocaleString()}</div>
            </div>
            <div class="stat-card warning">
              <div class="stat-number">${stats.missingInS2}</div>
              <div class="stat-label">Missing in Source 2</div>
              <div class="stat-meta">Potential Loss: ‚Çπ${stats.missingInS2Amount.toLocaleString()}</div>
            </div>
            <div class="stat-card danger">
              <div class="stat-number">${stats.duplicatesS1}</div>
              <div class="stat-label">Duplicates in Source 1</div>
              <div class="stat-meta">Double Count: ‚Çπ${stats.duplicatesS1Amount.toLocaleString()}</div>
            </div>
            <div class="stat-card danger">
              <div class="stat-number">${stats.duplicatesS2}</div>
              <div class="stat-label">Duplicates in Source 2</div>
              <div class="stat-meta">Double Count: ‚Çπ${stats.duplicatesS2Amount.toLocaleString()}</div>
            </div>
            <div class="stat-card warning">
              <div class="stat-number">${stats.missingInS1}</div>
              <div class="stat-label">Missing in Source 1</div>
              <div class="stat-meta">Untracked in S1: ‚Çπ${stats.missingInS1Amount.toLocaleString()}</div>
            </div>
            <div class="stat-card">
              <div class="stat-number">‚Çπ${stats.totalCommission.toLocaleString()}</div>
              <div class="stat-label">Total Commission (Source 1)</div>
              <div class="stat-meta">Average: ${stats.avgCommissionPct.toFixed(2)}%</div>
            </div>
          </div>
          <div class="table-container">
            <div class="table-header">
              <span class="table-title">Detailed Data Issues</span>
            </div>
            <div class="table-wrapper">
              <table>
                <thead>
                  <tr>
                    <th>App ID</th>
                    <th>Amount</th>
                    <th>Commission</th>
                    <th>Commission %</th>
                    <th>Branding</th>
                    <th>Status</th>
                    <th>Source</th>
                  </tr>
                </thead>
                <tbody>
                  ${[
                    ...missingInS2.map(r => rowHtml(r, "Missing in Source 2", "warning", "S1")),
                    ...duplicatesS1.map(r => rowHtml(r, "Duplicate in Source 1", "danger", "S1")),
                    ...missingInS1.map(r => rowHtml(r, "Missing in Source 1", "warning", "S2")),
                    ...duplicatesS2.map(r => rowHtml(r, "Duplicate in Source 2", "danger", "S2")),
                  ].join('')}
                </tbody>
              </table>
            </div>
          </div>
          <div class="success-msg">Analysis complete. Review the summary and details above.</div>
        `;
        DOM.results.classList.remove('hidden');
        DOM.exportSection.classList.remove('hidden');
        hideLoading();
        showSuccess('Analysis completed!');
      }, 400);
    });

    // Helper: Parse file rows into normalized objects
    function processFileRows(fileObj, cols, branding) {
      const out = [];
      const data = fileObj.data;
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (!row || row.length === 0) continue;
        let appId = row[cols.appId];
        if (appId == null || String(appId).trim() === "") continue;
        let amount = parseAmount(row[cols.amount]);
        let commission = cols.commission != null ? parseAmount(row[cols.commission]) : null;
        let commissionPct = (commission != null && amount) ? (commission/amount*100) : null;
        out.push({
          appId: String(appId).trim(),
          amount: amount,
          commission: commission,
          commissionPct: commissionPct!=null ? commissionPct.toFixed(2)+"%" : "",
          branding: branding,
          rowNum: i+1
        });
      }
      return out;
    }
    function parseAmount(value) {
      if (value === null || value === undefined || value === '') return 0;
      if (typeof value === 'number') return isNaN(value) ? 0 : value;
      if (typeof value === 'string') {
        const cleaned = value.replace(/[^\d.-]/g, '');
        const num = parseFloat(cleaned);
        return isNaN(num) ? 0 : num;
      }
      return 0;
    }
    function rowHtml(r, status, statusClass, src) {
      return `<tr class="highlight-${statusClass}">
        <td>${sanitizeHtml(r.appId)}</td>
        <td>‚Çπ${(r.amount||0).toLocaleString()}</td>
        <td>${r.commission !== undefined && r.commission !== null ? "‚Çπ" + r.commission.toLocaleString() : ""}</td>
        <td>${r.commissionPct||""}</td>
        <td>${sanitizeHtml(r.branding||'')}</td>
        <td><span class="status-badge ${statusClass}">${sanitizeHtml(status)}</span></td>
        <td>${sanitizeHtml(src)}</td>
      </tr>`;
    }

    // --- EXPORT TO EXCEL ---
    DOM.exportExcelBtn.addEventListener('click', () => {
      if (!STATE.exportRows || STATE.exportRows.length === 0) {
        showError("No results to export!");
        return;
      }
      const ws = XLSX.utils.aoa_to_sheet(STATE.exportRows);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Reconciliation Report");
      XLSX.writeFile(wb, `Reconciliation_Report_${new Date().toISOString().slice(0,10)}.xlsx`);
    });

    // --- PAGE INIT ---
    function updateUserInfo() {
      const now = new Date();
      DOM.userInfo.textContent = `User: ksismad | UTC ${now.getUTCFullYear()}-${String(now.getUTCMonth()+1).padStart(2,'0')}-${String(now.getUTCDate()).padStart(2,'0')} ${String(now.getUTCHours()).padStart(2,'0')}:${String(now.getUTCMinutes()).padStart(2,'0')}:${String(now.getUTCSeconds()).padStart(2,'0')}`;
    }
    updateUserInfo();
    setInterval(updateUserInfo, 15000);
    updateValidation();
  </script>
</body>
</html>
