<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>App ID Analyzer (ksismad)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <style>
    html, body { background: #f3f4f6; color: #1e293b; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0; }
    .container { max-width: 1200px; margin: 36px auto; background: #fff; border-radius: 18px; box-shadow: 0 8px 32px rgba(60,60,100,0.11); overflow: hidden; }
    .header { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: #fff; padding: 32px; position: relative; }
    .header h1 { margin: 0 0 8px; font-size: 2.25rem; }
    .user-info { position: absolute; top: 16px; right: 32px; background: rgba(255,255,255,0.15); padding: 7px 16px; border-radius: 20px; font-size: 0.93rem; }

    .upload-section { display: flex; gap: 24px; padding: 32px; flex-wrap: wrap; }
    .upload-box { flex: 1; min-width: 300px; background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 24px; position: relative; transition: border-color .2s, background .2s; }
    .upload-box.source2 { border-color: #059669; background: #f0fdf4; }
    .upload-box.source2::after { content: "(Paid Source)"; color: #059669; font-size: .875rem; display: block; margin-top:8px; }
    .upload-box.dragover { border-color: #6366f1; background: #eef4ff; }
    .file-input { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
    .upload-btn { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: #fff; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    .upload-btn.source2 { background: linear-gradient(135deg, #059669, #10b981); }
    .file-info { margin-top: 12px; padding:8px 16px; background: #d1fae5; color: #059669; border-radius:6px; display:none; }
    .file-info.show { display:inline-block; }
    .file-list {margin-top:8px;font-size:.98em;padding-left:0;list-style-type:none;}
    .file-list li{margin-bottom:2px;}
    .merge-btn {margin-top:8px;background:#38bdf8;color:#fff;border:none;padding:6px 16px;border-radius:6px;cursor:pointer;font-weight:600;}

    .column-mappings, .options-section, .results { padding: 0 32px; }
    .mapping-group, .option-group { margin-bottom: 24px; }
    select, input[type="number"] { padding:8px 12px; border:1px solid #cbd5e1; border-radius:6px; }
    .analyze-btn { width: calc(100% - 64px); margin:32px; padding:16px; background: linear-gradient(135deg, #10b981, #059669); color:#fff; border:none; border-radius:12px; font-size:1.2rem; font-weight:600; cursor:pointer;}
    .analyze-btn:disabled { background:#9ca3af; cursor:not-allowed; }

    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; margin: 24px 0; }
    .stat-card { background:#fff; padding:20px; border-radius:12px; box-shadow:0 2px 4px rgba(0,0,0,0.1); }
    .stat-card h3 { margin-top: 0; margin-bottom: 8px; color: #4b5563; }
    .stat-value { font-size: 1.5rem; font-weight: bold; color: #111827; margin-bottom: 4px; }
    .stat-subtext { font-size: 0.875rem; color: #6b7280; }

    .alert-container { display: flex; flex-wrap: wrap; gap: 16px; margin-bottom: 24px; }
    .alert-box { background: #fff7ed; border-left: 5px solid #f59e42; border-radius: 8px; box-shadow: 0 2px 8px rgba(60,60,100,0.06); padding: 16px; flex: 1 1 300px; }
    .alert-title { font-size: 1.1rem; font-weight: 700; margin-bottom: 4px; color: #d97706; }
    .alert-count { font-size: 1.2rem; font-weight: 800; color: #b45309; margin-bottom: 8px; }
    .alert-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    .alert-table th, .alert-table td { border-bottom: 1px solid #f3e8ff; padding: 6px 4px; text-align: left; }
    .alert-table th { background: #f8fafc; color: #4b5563; }
    .alert-table tr:last-child td { border-bottom: none; }
    .amount-cell { text-align: right; font-family: monospace; }
    .amount-cell.paid::after { content: " ‚úì"; color: #059669; }
    .paid-cell { color: #059669; font-weight: bold; }
    .unpaid-cell { color: #dc2626; font-weight: bold; }
    .variance-cell { text-align: right; font-family: monospace; font-weight: 600; }
    .positive-variance { color: #dc2626; }
    .negative-variance { color: #059669; }

    .loading-overlay { position:fixed; inset:0; background:rgba(255,255,255,0.9); display:flex; align-items:center; justify-content:center; z-index:1000; visibility:hidden; opacity:0; transition:opacity .2s; }
    .loading-overlay.show { visibility:visible; opacity:1; }
    .spinner { width:40px; height:40px; border:4px solid #f3f3f3; border-top:4px solid #3498db; border-radius:50%; animation:spin 1s linear infinite; }

    .error-message { margin:16px 32px; padding:12px 16px; background:#fee2e2; color:#b91c1c; border-radius:8px; display:none; }
    .error-message.show { display:block; }

    @keyframes spin { 0%{transform:rotate(0);}100%{transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="user-info" id="user-info">User: ksismad | UTC 2025-06-20 20:24:21</div>
      <h1>üîç App ID Analyzer</h1>
      <p>Compare and analyze app transaction data - red alert detection</p>
    </div>

    <div class="upload-section">
      <div class="upload-box" id="drop1">
        <h3>Source 1 Files</h3>
        <input type="file" id="file-input-1" class="file-input" multiple accept=".xlsx,.xls,.csv">
        <button class="upload-btn" id="upload-btn-1">Choose Files</button>
        <div id="file-info-1" class="file-info"></div>
        <ul id="file-list-1" class="file-list"></ul>
        <button id="merge-btn-1" class="merge-btn" style="display:none;">Merge Files</button>
      </div>
      <div class="upload-box source2" id="drop2">
        <h3>Source 2 File (Always Paid)</h3>
        <input type="file" id="file-input-2" class="file-input" accept=".xlsx,.xls,.csv">
        <button class="upload-btn source2" id="upload-btn-2">Choose File</button>
        <div id="file-info-2" class="file-info"></div>
      </div>
    </div>

    <div id="column-mappings" class="column-mappings"></div>

    <div class="options-section">
      <div class="option-group">
        <label>Analysis Type:</label>
        <select id="analysis-type">
          <option value="all">All Records</option>
          <option value="mismatches">Only Mismatches</option>
          <option value="missing">Only Missing Records</option>
        </select>
        <label><input type="checkbox" id="include-commission"> Include Commission Analysis</label>
        <label><input type="checkbox" id="apply-gst"> Apply 18% GST</label>
      </div>
      <div class="option-group">
        <label>Variance Threshold:</label>
        <input type="number" id="variance-threshold" value="0.01" step="0.01" min="0">
      </div>
    </div>

    <div id="error-message" class="error-message"></div>
    <button id="analyze-btn" class="analyze-btn" disabled>Analyze Data</button>
    <div id="results" class="results"></div>
  </div>

  <div id="loading-overlay" class="loading-overlay"><div class="spinner"></div></div>

  <script>
    // STATE
    const STATE = {
      source1Files: [], 
      source2File: null, 
      columnMappings: {},
      analysisOptions: { type:'all', includeCommission:false, applyGST:false, varianceThreshold:0.01 }
    };
    
    // DOM ELEMENTS
    function $(selector) {
      return document.querySelector(selector);
    }
    
    const DOM = {
      fileInput1: document.getElementById('file-input-1'),
      fileInput2: document.getElementById('file-input-2'),
      uploadBtn1: document.getElementById('upload-btn-1'),
      uploadBtn2: document.getElementById('upload-btn-2'),
      drop1: document.getElementById('drop1'),
      drop2: document.getElementById('drop2'),
      fileInfo1: document.getElementById('file-info-1'),
      fileInfo2: document.getElementById('file-info-2'),
      fileList1: document.getElementById('file-list-1'),
      mergeBtn1: document.getElementById('merge-btn-1'),
      columnMappings: document.getElementById('column-mappings'),
      analysisType: document.getElementById('analysis-type'),
      includeCommission: document.getElementById('include-commission'),
      applyGST: document.getElementById('apply-gst'),
      varianceThreshold: document.getElementById('variance-threshold'),
      analyzeBtn: document.getElementById('analyze-btn'),
      results: document.getElementById('results'),
      loadingOverlay: document.getElementById('loading-overlay'),
      errorMessage: document.getElementById('error-message'),
      userInfo: document.getElementById('user-info')
    };

    // UTILITIES
    function showLoading() { 
      DOM.loadingOverlay.classList.add('show'); 
    }
    
    function hideLoading() { 
      DOM.loadingOverlay.classList.remove('show'); 
    }
    
    function showError(msg) {
      console.error("Error:", msg);
      DOM.errorMessage.textContent = msg;
      DOM.errorMessage.classList.add('show');
      setTimeout(() => DOM.errorMessage.classList.remove('show'), 5000);
    }
    
    function updateUserInfo() {
      const now = new Date().toISOString().replace('T',' ').slice(0,19);
      DOM.userInfo.textContent = `User: ksismad | UTC ${now}`;
    }

    // FILE HANDLERS
    function initFileHandlers() {
      // Click handlers for upload buttons
      DOM.uploadBtn1.onclick = e => {
        e.preventDefault(); 
        DOM.fileInput1.value = ''; 
        DOM.fileInput1.click();
      };
      
      DOM.uploadBtn2.onclick = e => {
        e.preventDefault(); 
        DOM.fileInput2.value = ''; 
        DOM.fileInput2.click();
      };
      
      // File selection handlers
      DOM.fileInput1.onchange = e => { 
        if(e.target.files.length) handleFileSelection(e.target.files, 1); 
      };
      
      DOM.fileInput2.onchange = e => { 
        if(e.target.files.length) handleFileSelection([e.target.files[0]], 2); 
      };
      
      // Drag & drop handlers
      [
        {drop: DOM.drop1, src: 1}, 
        {drop: DOM.drop2, src: 2}
      ].forEach(o => {
        o.drop.ondragover = e => {
          e.preventDefault();
          e.stopPropagation();
          o.drop.classList.add('dragover');
        };
        
        o.drop.ondragleave = e => {
          e.preventDefault();
          e.stopPropagation();
          o.drop.classList.remove('dragover');
        };
        
        o.drop.ondrop = e => {
          e.preventDefault();
          e.stopPropagation();
          o.drop.classList.remove('dragover');
          const files = e.dataTransfer.files;
          if(files.length) handleFileSelection(o.src === 1 ? files : [files[0]], o.src);
        };
      });
      
      // Merge button handler
      DOM.mergeBtn1.onclick = showMergeDialog;
    }

    // File Processing
    function handleFileSelection(files, src) {
      if(!files.length) { 
        showError('No files selected'); 
        return;
      }
      
      showLoading();
      
      if(src === 1) {
        // Source 1 - can have multiple files
        STATE.source1Files = [];
        DOM.fileList1.innerHTML = '';
        
        Array.from(files).forEach((file, i) => {
          processExcelFile(file, (err, data) => {
            if(!err) {
              STATE.source1Files.push({
                file: file,
                headers: data[0],
                records: data.slice(1)
              });
              
              // Add to file list UI
              let li = document.createElement('li');
              li.textContent = file.name + ` (${data.length - 1} rows)`;
              DOM.fileList1.appendChild(li);
            } else { 
              showError(err.message); 
            }
            
            if(i === files.length - 1) { 
              DOM.fileInfo1.textContent = Array.from(files).map(x => x.name).join(', ');
              DOM.fileInfo1.classList.add('show');
              DOM.mergeBtn1.style.display = files.length > 1 ? 'inline-block' : 'none';
              hideLoading(); 
              setupColumnMappings(); 
              updateAnalyzeBtn();
            }
          });
        });
      } else {
        // Source 2 - single file 
        const file = files[0];
        processExcelFile(file, (err, data) => {
          if(!err) {
            STATE.source2File = {
              file: file,
              headers: data[0],
              records: data.slice(1).map(r => ({...r, isPaid: true})) // Always mark S2 as paid
            };
            DOM.fileInfo2.textContent = file.name; 
            DOM.fileInfo2.classList.add('show');
            
            setupColumnMappings(); 
            updateAnalyzeBtn();
          } else {
            showError(err.message);
          }
          hideLoading();
        });
      }
    }

    function processExcelFile(file, cb) {
      const reader = new FileReader();
      
      reader.onload = e => {
        try {
          const workbook = XLSX.read(new Uint8Array(e.target.result), {type: 'array'});
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
          
          if(jsonData.length < 2) return cb(new Error('File has no data rows'));
          cb(null, jsonData);
        } catch(err) {
          cb(err);
        }
      };
      
      reader.onerror = () => cb(new Error('Error reading file'));
      reader.readAsArrayBuffer(file);
    }

    function showMergeDialog() {
      if (STATE.source1Files.length < 2) return;
      
      const fileNames = STATE.source1Files.map((f, i) => `${i + 1}. ${f.file.name}`);
      const sourceIndex = prompt(`Select source file to merge FROM:\n\n${fileNames.join('\n')}`);
      
      if (!sourceIndex) return;
      
      const targetIndex = prompt(`Select target file to merge INTO:\n\n${fileNames.join('\n')}`);
      
      if (!targetIndex) return;
      
      // Convert string inputs to numbers and adjust to 0-based index
      const srcIdx = parseInt(sourceIndex) - 1;
      const tgtIdx = parseInt(targetIndex) - 1;
      
      // Validate indices
      if (isNaN(srcIdx) || isNaN(tgtIdx) || 
          srcIdx < 0 || tgtIdx < 0 || 
          srcIdx >= STATE.source1Files.length || 
          tgtIdx >= STATE.source1Files.length ||
          srcIdx === tgtIdx) {
        showError("Invalid file selection");
        return;
      }
      
      // Get files
      const sourceFile = STATE.source1Files[srcIdx];
      const targetFile = STATE.source1Files[tgtIdx];
      
      // Check header compatibility
      if (sourceFile.headers.length !== targetFile.headers.length) {
        showError("Files have different column counts");
        return;
      }
      
      // Merge records from source to target
      targetFile.records = targetFile.records.concat(sourceFile.records);
      
      // Remove source file from array
      STATE.source1Files.splice(srcIdx, 1);
      
      // Update UI
      DOM.fileList1.innerHTML = '';
      STATE.source1Files.forEach((f, i) => {
        const li = document.createElement('li');
        li.textContent = f.file.name + ` (${f.records.length} rows)`;
        DOM.fileList1.appendChild(li);
      });
      
      DOM.mergeBtn1.style.display = STATE.source1Files.length > 1 ? 'inline-block' : 'none';
      
      // Update mappings
      setupColumnMappings();
    }

    // COLUMN MAPPING
    function setupColumnMappings() {
      const s1Headers = STATE.source1Files[0]?.headers || [];
      const s2Headers = STATE.source2File?.headers || [];
      
      if(!s1Headers.length || !s2Headers.length) return;
      
      // Define columns to map
      const columns = [
        {id: 'appId', lbl: 'App ID', pattern: [/app.*id/i, /id/i], required: true},
        {id: 'amount', lbl: 'Amount', pattern: [/amount/i, /total/i], required: true},
        {id: 'commission', lbl: 'Commission (S1)', pattern: [/commiss|tds|fee|charge/i], s2: false},
        {id: 'date', lbl: 'Date', pattern: [/date/i, /timestamp/i], required: true}
      ];
      
      // Status is not needed for S2 (always "Paid"), so we exclude it from the UI
      
      let html = `<div class="mapping-group"><strong>Column Mappings</strong>`;
      
      columns.forEach(col => {
        html += `<div><label>${col.lbl}:</label>
                <select id="ms1-${col.id}"><option value="">Select S1</option>${
                  s1Headers.map((h, i) => `<option value="${i}">${h || `Column ${i+1}`}</option>`).join('')
                }</select>`;
        
        // Only add S2 mapping for fields that need it (not commission)
        if (col.s2 !== false) {
          html += `<select id="ms2-${col.id}"><option value="">Select S2</option>${
                    s2Headers.map((h, i) => `<option value="${i}">${h || `Column ${i+1}`}</option>`).join('')
                  }</select>`;
        } else {
          html += `<span style="display:inline-block;width:150px;padding:8px;color:#666;font-style:italic;">Not needed for S2</span>`;
        }
        
        html += `</div>`;
      });
      
      html += `</div>`;
      DOM.columnMappings.innerHTML = html;
      
      // Set default values based on auto-detection
      columns.forEach(col => {
        const s1Select = document.getElementById(`ms1-${col.id}`);
        const autoDetectS1 = findMatch(s1Headers, col.pattern);
        if (autoDetectS1 !== '') s1Select.value = autoDetectS1;
        
        if (col.s2 !== false) {
          const s2Select = document.getElementById(`ms2-${col.id}`);
          const autoDetectS2 = findMatch(s2Headers, col.pattern);
          if (autoDetectS2 !== '') s2Select.value = autoDetectS2;
          s2Select.onchange = updateColumnMappings;
        }
        
        s1Select.onchange = updateColumnMappings;
      });
      
      updateColumnMappings();
    }

    function findMatch(headers, patterns) {
      for(let pattern of patterns) {
        const index = headers.findIndex(h => h && pattern.test(h));
        if(index !== -1) return index;
      }
      return '';
    }

    function updateColumnMappings() {
      STATE.columnMappings = {};
      
      ['appId', 'amount', 'commission', 'date'].forEach(id => {
        const s1Element = document.getElementById(`ms1-${id}`);
        // Only check s2 elements for fields that have them
        const s2Element = id !== 'commission' ? document.getElementById(`ms2-${id}`) : null;
        
        STATE.columnMappings[id] = {
          source1: s1Element ? s1Element.value : "",
          source2: s2Element ? s2Element.value : ""
        };
      });
      
      updateAnalyzeBtn();
    }

    function updateAnalyzeBtn() {
      // Button enabled if we have files and required mappings
      const requiredMappings = ['appId', 'amount', 'date'];
      
      const s1Valid = STATE.source1Files.length > 0;
      const s2Valid = STATE.source2File !== null;
      
      const mappingsValid = requiredMappings.every(id => {
        const mapping = STATE.columnMappings[id];
        return mapping && mapping.source1 !== "" && (id === 'commission' || mapping.source2 !== "");
      });
      
      const allValid = s1Valid && s2Valid && mappingsValid;
      
      DOM.analyzeBtn.disabled = !allValid;
      DOM.analyzeBtn.textContent = allValid ? 'Analyze Data' : 'Select Required Mappings';
    }

    // GST calculation
    function applyGST(amount) {
      if (!DOM.applyGST.checked) return amount;
      
      // Apply 18% GST
      return amount * 1.18;
    }

    // STATUS DETECTION
    // S1: Commission blank/zero = "Unpaid", otherwise "Paid"
    function getS1Status(row, commissionIndex) {
      // If commission field exists and has a value, consider "Paid"
      if (commissionIndex !== undefined && commissionIndex !== null && commissionIndex !== "") {
        const commValue = row[commissionIndex];
        
        // Check if commission field is empty or zero
        if (commValue === undefined || commValue === null || commValue === "" || 
            Number(commValue) === 0 || 
            (typeof commValue === "string" && commValue.trim() === "")) {
          return "Unpaid";
        }
      } else {
        // No commission column, default to "Unpaid"
        return "Unpaid";
      }
      
      // Has commission value, so status is "Paid"
      return "Paid";
    }

    // ANALYSIS
    function analyzeData() {
      try {
        const s1 = STATE.source1Files[0];
        const s2 = STATE.source2File;
        
        // Safety check
        if (!s1 || !s2) {
          showError("Missing source files");
          return {};
        }
        
        const s1Records = s1.records;
        const s2Records = s2.records;
        const mappings = STATE.columnMappings;
        const varianceThreshold = parseFloat(DOM.varianceThreshold.value) || 0.01;
        
        // Get column indices
        const s1AppIdIdx = parseInt(mappings.appId.source1);
        const s1AmountIdx = parseInt(mappings.amount.source1);
        const s1DateIdx = parseInt(mappings.date.source1);
        const s1CommissionIdx = mappings.commission ? parseInt(mappings.commission.source1) : null;
        
        const s2AppIdIdx = parseInt(mappings.appId.source2);
        const s2AmountIdx = parseInt(mappings.amount.source2);
        const s2DateIdx = parseInt(mappings.date.source2);
        
        // Create result object
        const results = {
          matches: 0,
          mismatches: [],
          missing: [],
          redAlerts: [],
          commissionDeviations: []
        };
        
        // Index S2 by App ID for quick lookup
        const s2Map = new Map();
        s2Records.forEach(record => {
          const appId = record[s2AppIdIdx];
          if (appId) s2Map.set(String(appId), record);
        });
        
        // Create duplicate maps
        const s1DupMap = {}, s2DupMap = {};
        s1Records.forEach(r => {
          const id = r[s1AppIdIdx];
          if (!id) return;
          s1DupMap[id] = (s1DupMap[id] || 0) + 1;
        });
        
        s2Records.forEach(r => {
          const id = r[s2AppIdIdx];
          if (!id) return;
          s2DupMap[id] = (s2DupMap[id] || 0) + 1;
        });
        
        // Process S1 records
        s1Records.forEach(r1 => {
          const appId = r1[s1AppIdIdx];
          if (!appId) return; // Skip if no App ID
          
          const r2 = s2Map.get(String(appId));
          const s1Status = getS1Status(r1, s1CommissionIdx);
          const s2Status = "Paid"; // Always "Paid" for S2
          
          // Get amounts 
          let amount1 = parseFloat(r1[s1AmountIdx]) || 0;
          let amount2 = r2 ? parseFloat(r2[s2AmountIdx]) || 0 : 0;
          
          // Apply GST if needed
          if (DOM.applyGST.checked) {
            amount1 = applyGST(amount1);
            amount2 = applyGST(amount2);
          }
          
          // COMPARISON LOGIC
          if (r2) {
            // Both S1 and S2 have this record
            const variance = amount2 - amount1;
            const absVariance = Math.abs(variance);
            
            if (absVariance <= varianceThreshold) {
              // Amounts match within threshold
              results.matches++;
            } else {
              // Amounts differ beyond threshold
              const item = {
                appId: appId,
                s1Amount: amount1,
                s2Amount: amount2,
                variance: variance,
                s1Status: s1Status,
                s2Status: s2Status,
                date: r1[s1DateIdx] || 'N/A'
              };
              
              results.mismatches.push(item);
              
              // Different scenarios based on status
              if (s1Status === "Paid" && s2Status === "Paid") {
                // Both paid but amounts differ
                results.redAlerts.push({
                  ...item,
                  scenario: "S1 Paid, S2 Paid but amount different"
                });
              } else if (s1Status === "Unpaid" && s2Status === "Paid") {
                // S2 paid but S1 unpaid
                results.redAlerts.push({
                  ...item,
                  scenario: "S2 Paid, S1 Unpaid and amount different"
                });
              }
              
              // Check commission deviation
              if (DOM.includeCommission.checked && s1Status === "Paid" && s1CommissionIdx !== null) {
                const commValue = parseFloat(r1[s1CommissionIdx]) || 0;
                const expectedCommission = amount1 * 0.02; // 2% commission
                
                if (Math.abs(commValue - expectedCommission) > 0.01) {
                  results.commissionDeviations.push({
                    appId: appId,
                    s1Amount: amount1,
                    commission: commValue,
                    expectedCommission: expectedCommission,
                    date: r1[s1DateIdx] || 'N/A'
                  });
                }
              }
            }
            
          } else {
            // In S1 but missing from S2
            results.missing.push({
              appId: appId,
              amount: amount1,
              status: s1Status,
              date: r1[s1DateIdx] || 'N/A',
              source: 'source1'
            });
            
            // If S1 is paid, it's a red alert when missing from S2
            if (s1Status === "Paid") {
              results.redAlerts.push({
                appId: appId,
                s1Amount: amount1,
                s1Status: s1Status,
                date: r1[s1DateIdx] || 'N/A',
                scenario: "S1 Paid but missing in S2"
              });
            }
          }
          
          // Check for duplicates in S1
          if (s1DupMap[appId] > 1) {
            results.redAlerts.push({
              appId: appId,
              s1Amount: amount1,
              s1Status: s1Status,
              date: r1[s1DateIdx] || 'N/A',
              scenario: "Duplicates in S1"
            });
          }
        });
        
        // Process S2 records to find those missing from S1
        s2Records.forEach(r2 => {
          const appId = r2[s2AppIdIdx];
          if (!appId) return;
          
          // Check if exists in S1
          const s1HasApp = s1Records.some(r1 => r1[s1AppIdIdx] == appId);
          
          if (!s1HasApp) {
            // In S2 but missing from S1
            const amount2 = parseFloat(r2[s2AmountIdx]) || 0;
            
            results.missing.push({
              appId: appId,
              amount: DOM.applyGST.checked ? applyGST(amount2) : amount2,
              status: "Paid", // S2 is always Paid
              date: r2[s2DateIdx] || 'N/A',
              source: 'source2'
            });
            
            // S2 is always Paid, so missing from S1 is a red alert
            results.redAlerts.push({
              appId: appId,
              s2Amount: DOM.applyGST.checked ? applyGST(amount2) : amount2,
              s2Status: "Paid",
              date: r2[s2DateIdx] || 'N/A',
              scenario: "S2 Paid but missing in S1"
            });
          }
          
          // Check for duplicates in S2
          if (s2DupMap[appId] > 1) {
            results.redAlerts.push({
              appId: appId,
              s2Amount: DOM.applyGST.checked ? applyGST(parseFloat(r2[s2AmountIdx]) || 0) : (parseFloat(r2[s2AmountIdx]) || 0),
              s2Status: "Paid",
              date: r2[s2DateIdx] || 'N/A',
              scenario: "Duplicates in S2"
            });
          }
        });
        
        // Calculate totals
        results.redAlertsTotal = results.redAlerts.reduce((sum, item) => 
          sum + (item.variance || item.s2Amount || item.s1Amount || 0), 0);
          
        results.commissionDeviationsTotal = results.commissionDeviations.reduce((sum, item) => 
          sum + Math.abs((item.commission || 0) - (item.expectedCommission || 0)), 0);
          
        results.totalPotentialLoss = results.redAlertsTotal + results.commissionDeviationsTotal;
        
        console.log("Analysis complete", results);
        return results;
      } catch (error) {
        console.error("Analysis error:", error);
        showError(`Analysis error: ${error.message || error}`);
        return {};
      }
    }

    // DISPLAY RESULTS
    function displayResults(results) {
      if (!results) {
        showError("No analysis results available");
        return;
      }
      
      try {
        // Display summary statistics
        let html = `
          <div class="results-header">
            <h2>Analysis Results</h2>
          </div>
          
          <div class="stats-grid">
            <div class="stat-card">
              <h3>Total Potential Loss</h3>
              <div class="stat-value">‚Çπ${(results.totalPotentialLoss || 0).toFixed(2)}</div>
              <div class="stat-subtext">(Red Alerts + Commission Deviations)</div>
            </div>
            
            <div class="stat-card">
              <h3>Red Alerts</h3>
              <div class="stat-value">${results.redAlerts ? results.redAlerts.length : 0}</div>
              <div class="stat-subtext">‚Çπ${(results.redAlertsTotal || 0).toFixed(2)}</div>
            </div>
            
            <div class="stat-card">
              <h3>Commission Deviations</h3>
              <div class="stat-value">${results.commissionDeviations ? results.commissionDeviations.length : 0}</div>
              <div class="stat-subtext">‚Çπ${(results.commissionDeviationsTotal || 0).toFixed(2)}</div>
            </div>
            
            <div class="stat-card">
              <h3>Total Records</h3>
              <div class="stat-value">${(results.matches || 0) + 
                                      (results.mismatches ? results.mismatches.length : 0) + 
                                      (results.missing ? results.missing.length : 0)}</div>
              <div class="stat-subtext">${results.matches || 0} matches, ${results.mismatches ? results.mismatches.length : 0} mismatches, ${results.missing ? results.missing.length : 0} missing</div>
            </div>
          </div>`;
          
        // Group red alerts by scenario
        if (results.redAlerts && results.redAlerts.length > 0) {
          // Group alerts by scenario
          const scenarioMap = {};
          results.redAlerts.forEach(alert => {
            const scenario = alert.scenario || "Other Alerts";
            if (!scenarioMap[scenario]) scenarioMap[scenario] = [];
            scenarioMap[scenario].push(alert);
          });
          
          html += `<h2>Red Alert Scenarios</h2><div class="alert-container">`;
          
          // Display each scenario group
          Object.entries(scenarioMap).forEach(([scenario, alerts]) => {
            html += `
              <div class="alert-box">
                <div class="alert-title">${scenario}</div>
                <div class="alert-count">${alerts.length}</div>
                <table class="alert-table">
                  <thead><tr>`;
                  
            // Determine columns based on first item
            const firstAlert = alerts[0];
            const columns = Object.keys(firstAlert).filter(k => k !== 'scenario');
            
            html += columns.map(col => `<th>${col.replace(/([A-Z])/g, ' $1')}</th>`).join('');
            html += `</tr></thead><tbody>`;
            
            // Show at most 8 records per scenario
            alerts.slice(0, 8).forEach(alert => {
              html += `<tr>`;
              
              columns.forEach(col => {
                let value = alert[col];
                let cellClass = '';
                
                // Style based on column
                if (col.includes('Status')) {
                  cellClass = value === 'Paid' ? 'paid-cell' : 'unpaid-cell';
                } else if (col.includes('Amount')) {
                  cellClass = 'amount-cell';
                } else if (col.includes('variance')) {
                  cellClass = 'variance-cell ' + (value > 0 ? 'positive-variance' : 'negative-variance');
                }
                
                // Format numeric values
                if (typeof value === 'number') {
                  value = value.toFixed(2);
                }
                
                html += `<td class="${cellClass}">${value || 'N/A'}</td>`;
              });
              
              html += `</tr>`;
            });
            
            html += `</tbody></table>`;
            
            // Show count if more items exist
            if (alerts.length > 8) {
              html += `<div style="margin-top:8px;font-size:0.85rem;color:#666;">+ ${alerts.length - 8} more records</div>`;
            }
            
            html += `</div>`;
          });
          
          html += `</div>`;
        } else {
          html += `<div style="margin:24px 0;padding:16px;background:#f0fdf4;border-radius:8px;text-align:center;">
            <h3 style="color:#059669;margin:0;">No Red Alerts Found</h3>
          </div>`;
        }
        
        // Set the HTML and show results
        DOM.results.innerHTML = html;
        DOM.results.classList.add('show');
        
        // Scroll to results
        DOM.results.scrollIntoView({behavior: 'smooth'});
      } catch (error) {
        console.error("Display error:", error);
        showError(`Error displaying results: ${error.message || error}`);
      }
    }

    // EVENT HANDLERS
    DOM.analyzeBtn.onclick = () => {
      showLoading();
      
      // Small delay to let UI update
      setTimeout(() => {
        try {
          const results = analyzeData();
          displayResults(results);
        } catch (error) {
          showError(`Analysis failed: ${error.message || error}`);
        }
        hideLoading();
      }, 100);
    };

    // INITIALIZATION
    document.addEventListener('DOMContentLoaded', () => {
      // Setup event handlers
      initFileHandlers();
      
      // Set initial time
      updateUserInfo();
      
      // Update time periodically
      setInterval(updateUserInfo, 15000);
      
      // Setup analysis option handlers
      DOM.analysisType.onchange = () => {
        STATE.analysisOptions.type = DOM.analysisType.value;
      };
      
      DOM.includeCommission.onchange = () => {
        STATE.analysisOptions.includeCommission = DOM.includeCommission.checked;
      };
      
      DOM.applyGST.onchange = () => {
        STATE.analysisOptions.applyGST = DOM.applyGST.checked;
      };
      
      DOM.varianceThreshold.onchange = () => {
        STATE.analysisOptions.varianceThreshold = parseFloat(DOM.varianceThreshold.value) || 0.01;
      };
      
      console.log("App ID Analyzer initialized");
    });
  </script>
</body>
</html>
